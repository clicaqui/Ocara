#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  Copyright (C) 2008 Wilson Pinto Jￃﾺnior <wilson@openlanhouse.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import gtk
import logging
import gobject
import datetime
import time
import webbrowser
import os
import string

from OcaraServer.globals import *
_ = gettext.gettext

from os import name as osname
from os import path as ospath
from os import remove as os_remove
from time import localtime
from threading import Lock

from OcaraServer.ui import icons, DateEdit, HourEntry
from OcaraServer.ui.SearchEntry import SearchEntry
from OcaraServer.ui.utils import color_entry, get_gtk_builder

from OcaraServer.utils import user_has_avatar, get_user_avatar_path, generate_ticket
from OcaraServer.db.models import CashFlowItem, User, Block, BlockBorrow, Telecentro, Occupation, Address, RegistroGeral, CertidaoNascimento, RendaFamiliar, MaritalStatus, TypeDeficiency, SituationOccupation, City
from OcaraServer.db.models import Heritage, AlienationMachine, ReserveOfBorrow, ScheduleOfBorrow, AlienationMachine, Pais, State, Etnia, Schooling, Perfil, Perfil_User
from OcaraServer.db.models import Action, ActionCategory, PerfilAction
from OcaraCore.utils import md5_cripto
from OcaraCore.utils import calculate_time, calculate_credit
from OcaraCore.utils import check_nick, check_name, check_phone, check_email, check_password, check_confirm_password, check_cpf, check_cep
from OcaraCore.utils import is_in_path, execute_command, threaded
from OcaraCore.ConfigClient import get_default_client
from OcaraCore.cpf import CPF
from OcaraServer.db.models import OpenDebtOtherItem, OpenDebtMachineItem

GNOME_OPEN_PATH = is_in_path('gnome-open')

(URL_TYPE_SITE,
 URL_TYPE_EMAIL) = range(2)

@threaded
def gnome_open_link(obj, link, url_type):
    if url_type == URL_TYPE_SITE:
        command = [GNOME_OPEN_PATH, link]
    elif url_type == URL_TYPE_EMAIL:
        command = [GNOME_OPEN_PATH, "mailto:" + link]

    execute_command(command)

@threaded
def common_open_link(obj, link, url_type):
    if url_type == URL_TYPE_SITE:
        webbrowser.open(link)

if GNOME_OPEN_PATH:
    open_link = gnome_open_link
    gtk.about_dialog_set_email_hook(open_link, URL_TYPE_EMAIL) #GNOME supports email

else:
    open_link = common_open_link

gtk.about_dialog_set_url_hook(open_link, URL_TYPE_SITE)
gtk.link_button_set_uri_hook(open_link, URL_TYPE_SITE)

class about(gtk.AboutDialog):
    def __init__(self, logo, Parent=None):

        gtk.AboutDialog.__init__(self)

        page = ()

        if APP_AUTHORS:
            page = page + (_("Ocara:\n"),) + APP_AUTHORS + ('',)

        if APP_CONTRIB:
            page = page + (_('Openlanhouse:\n'),) + APP_CONTRIB

        if Parent:
            self.set_transient_for(Parent)

        self.set_name(_("Ocara"))
        self.set_version(APP_VERSION)

        self.set_website(APP_SITE)
        self.set_website_label(_('Ocara Website'))
        self.set_logo(logo)
        #self.set_copyright(APP_COPYRIGHT)
        self.set_documenters(APP_DOCS)
        self.set_comments(APP_COMMENTS)
        self.set_authors(page)
        self.set_artists(APP_ARTISTS)
        self.set_license(APP_LICENCE)

        self.run()
        self.destroy()

class yes_no(gtk.MessageDialog):
    def __init__(self, text, Parent=None, title=None,
                    ICON=gtk.MESSAGE_QUESTION, buttons=gtk.BUTTONS_YES_NO,
                    default_response=gtk.RESPONSE_YES):

        gtk.MessageDialog.__init__(self, Parent, gtk.DIALOG_MODAL,
                                   ICON, buttons, text)

        if title:
            self.set_title(title)

        self.set_markup(text)

        self.response = self.run() == default_response
        self.destroy()

class delete(gtk.MessageDialog):
    def __init__(self, text, Parent=None, ICON=gtk.MESSAGE_QUESTION):

        gtk.MessageDialog.__init__(self, Parent,
                        gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                        ICON, gtk.BUTTONS_NONE, text)

        self.set_markup(text)
        self.hbox = self.vbox.get_children()[2]
        self.response = None

        #Buttons
        bnt1 = gtk.Button(stock=gtk.STOCK_CANCEL, use_underline=True)
        bnt2 = gtk.Button(stock=gtk.STOCK_DELETE, use_underline=True)

        self.hbox.pack_start(bnt1)
        self.hbox.pack_start(bnt2)

        bnt1.show()
        bnt2.show()

        #conect
        bnt1.connect("clicked", self.callback, False)
        bnt2.connect("clicked", self.callback, True)

        self.run()

    def callback(self, widget, response):
        """
            Callback to get response
        """
        self.response = response
        self.destroy()


class exit(gtk.MessageDialog):

    def __init__(self, text, Parent=None,
                 allow_miminize=True, ICON=gtk.MESSAGE_QUESTION):
        """
            Create exit Dialog
        """

        gtk.MessageDialog.__init__(self, Parent, gtk.DIALOG_MODAL, ICON,
                                   gtk.BUTTONS_NONE, text)

        self.set_markup(text)
        self.hbox = self.vbox.get_children()[2]
        self.response = None

        #Buttons
        if allow_miminize:
            bnt1 = gtk.Button(label=_('Miminize to _Tray'), use_underline=True)

        bnt2 = gtk.Button(stock=gtk.STOCK_NO, use_underline=True)
        bnt3 = gtk.Button(stock=gtk.STOCK_YES, use_underline=True)
        bnts = [bnt2, bnt3]

        if allow_miminize:
            bnts.insert(0, bnt1)

        for bnt in bnts:
            self.hbox.pack_start(bnt)
            bnt.show()

        #conect
        if allow_miminize:
            bnt1.connect("clicked", self.callback, 2) #Minimize

        bnt2.connect("clicked", self.callback, gtk.RESPONSE_CANCEL)
        bnt3.connect("clicked", self.callback, gtk.RESPONSE_YES)

        self.run()
        self.destroy()

    def callback(self, widget, response):
        """
            Callback to get response
        """
        self.response = response
        self.destroy()

class ok_only(gtk.MessageDialog):
    def __init__(self, text, Parent=None, title=None, ICON=gtk.MESSAGE_INFO):

        gtk.MessageDialog.__init__(self, Parent, gtk.DIALOG_MODAL, ICON,
                                   gtk.BUTTONS_OK, text)

        if title:
            self.set_title(title)

        self.set_markup(text)
        self.run()
        self.destroy()

class image_chooser_button(gtk.FileChooserButton):
    def __init__(self):
        gtk.FileChooserButton.__init__(self, title='Escolha a imagem')

        self.toggle = gtk.CheckButton("Preview images")
        self.set_extra_widget(self.toggle)
        self.toggle.set_active(True)
        self.toggle.connect('toggled', self.toggled_cb)
        self.toggle.show()
        self.use_preview = True

        filter = gtk.FileFilter()
        filter.set_name(_('All files'))
        filter.add_pattern('*')
        self.add_filter(filter)

        filter = gtk.FileFilter()
        filter.set_name(_('Images') )
        filter.add_mime_type('image/png')
        filter.add_mime_type('image/jpeg')
        filter.add_mime_type('image/gif')
        filter.add_mime_type('image/tiff')
        filter.add_mime_type('image/svg+xml')
        filter.add_mime_type('image/x-xpixmap')
        self.add_filter(filter)
        self.set_filter(filter)

        if osname == 'posix' and ospath.exists('/usr/share/pixmaps'):
            self.add_shortcut_folder('/usr/share/pixmaps')

        self.set_use_preview_label(False)
        self.previewidget = gtk.Image()
        self.set_preview_widget(self.previewidget)
        self.connect("update-preview", self.update_preview_cb, self.previewidget)

    def update_preview_cb(self, file_chooser, preview):

        if not self.use_preview:
            return

        filename = file_chooser.get_preview_filename()

        try:
            pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(filename,
                                            PREVIEW_SIZE, PREVIEW_SIZE)
            self.previewidget.set_from_pixbuf(pixbuf)
            self.have_preview = True

        except:
            self.have_preview = False

        self.set_preview_widget_active(self.have_preview)
        return

    def toggled_cb(self, obj):
        if obj.get_active():
            filename = self.get_preview_filename()

            try:
                pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(filename,
                                            PREVIEW_SIZE, PREVIEW_SIZE)
                self.previewidget.set_from_pixbuf(pixbuf)
                self.have_preview = True
            except:
                self.have_preview = False

            self.set_preview_widget_active(self.have_preview)
            self.use_preview = True

        else:
            self.set_preview_widget_active(False)
            self.use_preview = False

class ImageChooserDialog(gtk.FileChooserDialog):
    def __init__(self, parent=None):
        gtk.FileChooserDialog.__init__(self, title='Escolha a imagem',
                                       parent=parent,
                                       action=gtk.FILE_CHOOSER_ACTION_OPEN,
                                       buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                                                gtk.STOCK_OPEN, gtk.RESPONSE_OK,
                                                _("_No Image"), gtk.RESPONSE_NONE))

        self.toggle = gtk.CheckButton("Preview images")
        self.set_extra_widget(self.toggle)
        self.toggle.set_active(True)
        self.toggle.connect('toggled', self.toggled_cb)
        self.toggle.show()
        self.use_preview = True

        filter = gtk.FileFilter()
        filter.set_name(_('Todos os arquivos'))
        filter.add_pattern('*')
        self.add_filter(filter)

        filter = gtk.FileFilter()
        filter.set_name(_('Images') )
        filter.add_mime_type('image/png')
        filter.add_mime_type('image/jpeg')
        filter.add_mime_type('image/gif')
        filter.add_mime_type('image/tiff')
        filter.add_mime_type('image/svg+xml')
        filter.add_mime_type('image/x-xpixmap')
        self.add_filter(filter)
        self.set_filter(filter)

        if osname == 'posix' and ospath.exists('/usr/share/pixmaps'):
            self.add_shortcut_folder('/usr/share/pixmaps')

        self.set_use_preview_label(False)
        self.previewidget = gtk.Image()
        self.set_preview_widget(self.previewidget)
        self.connect("update-preview", self.update_preview_cb, self.previewidget)

    def update_preview_cb(self, file_chooser, preview):

        if not self.use_preview:
            return

        filename = file_chooser.get_preview_filename()

        try:
            pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(filename,
                                            PREVIEW_SIZE, PREVIEW_SIZE)
            self.previewidget.set_from_pixbuf(pixbuf)
            self.have_preview = True

        except:
            self.have_preview = False

        self.set_preview_widget_active(self.have_preview)
        return

    def toggled_cb(self, obj):
        if obj.get_active():
            filename = self.get_preview_filename()

            try:
                pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(filename,
                                            PREVIEW_SIZE, PREVIEW_SIZE)
                self.previewidget.set_from_pixbuf(pixbuf)
                self.have_preview = True
            except:
                self.have_preview = False

            self.set_preview_widget_active(self.have_preview)
            self.use_preview = True

        else:
            self. set_preview_widget_active(False)
            self.use_preview = False

    def run(self):
        response = gtk.FileChooserDialog.run(self)
        file = self.get_filename()
        self.hide()
        return response, file


class edit_heritage:

    ui_file = 'edit_heritage'

    data = {}
    data['description'] = ""

    input = {}
    faults = []

    accept_first_new = False

    def __init__(self, manager, Parent=None):

        self.manager = manager
        self.list_bens_manager = self.manager.list_bens_manager

        self.xml = get_gtk_builder(self.ui_file)
        self.edit_heritage = self.xml.get_object(self.ui_file)
        self.xml.connect_signals(self)

        self.apply_bnt = self.xml.get_object('apply_bnt')
        self.description = self.xml.get_object('description')
        self.description_buffer = self.description.get_buffer()
        self.cancel_bnt = self.xml.get_object('cancel_bnt')

        self.reg_entry("name")
        self.reg_entry("number_ben")
        self.reg_entry("value")
        self.reg_entry("model")
        self.reg_entry("brand")

        self.cancel_bnt = gtk.Button(stock=gtk.STOCK_CANCEL)
        self.cancel_bnt.connect("clicked", self.on_cancel_button_clicked)

        self.apply_bnt = gtk.Button(stock=gtk.STOCK_SAVE)
        self.apply_bnt.set_sensitive(False)
        self.apply_bnt.connect("clicked", self.on_apply_bnt_clicked)
        self.apply_bnt.set_no_show_all(True)

        if Parent:
            self.edit_heritage.set_transient_for(Parent)

    def reg_entry(self, name):

        widget = self.xml.get_object(name)
        self.data[name] = ""
        self.input[name] = widget

        return widget


    def get_data(self):

        newdata = {}
        bf = self.description_buffer
        newdata['description'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())

        newdata['id'] = self.data['id']

        for key in self.input.keys():
            newdata[key] = self.input[key].get_text()

        return newdata

    def get_new_data(self):

        new = self.get_data()

        def f(x):
            return x[1] != self.data[x[0]]

        return dict(filter(f, zip(new.keys(), new.values())))


    def on_cancel_button_clicked(self, obj):
        self.edit_heritage.destroy()

    def on_apply_bnt_clicked(self, obj):
        data = self.get_new_data()

        if data:

            for key, value in data.items():
                self.heritage.__setattr__(key, value)
		
            self.list_bens_manager.update(self.heritage)

        self.edit_heritage.destroy()

    def reset_data(self):

        for key in self.input.keys():
            self.data[key] = ""
            self.input[key].set_text("")

        self.data['description'] = ""

        self.description_buffer.set_text("")

    def set_data(self, heritage):

        self.reset_data()

        for key in self.input:
            value = heritage.__getattribute__(key)

            if value:
                self.data[key] = value
                self.input[key].set_text(self.data[key])

        if heritage.description:
            self.data['description'] = heritage.description
            self.description_buffer.set_text(self.data['description'])

        self.data['id'] = heritage.id

    def run(self, heritage):

	self.heritage = heritage
        if heritage:
	    self.set_data(self.heritage)
	    self.edit_heritage.show()
        else:
            self.edit_heritage.destroy()


class user_edit:
    """
       Classe responsavel por editar o usuario
    """

    ui_file = 'edit_user'
    nick_found = False

    data = {}
    data['notes'] = ""
    data['address'] = ""
    data['birth'] = None
    data['data_expedicao'] = None
    data['curriculo'] = ""
    data['category_id'] = 0
    data['sex'] = 0
    data['occupation'] = 0
    data['etnia'] = 0
    data['schooling'] = 0
    data['state'] = 0
    data['staterg'] = 0
    data['pais'] = 0
    data['type_deficiency'] = 0
    data['renda_familiar'] = 0
    data['marital_status'] = 0
    data['situation_occupation'] = 0
    data['city'] = 0

    input = {}
    errs = []
    warns = []
    faults = []
    category_iters = {}
    sex_iters = {}
    which_iters = {}
    occupation_iters = {}
    etnia_iters = {}
    schooling_iters = {}
    state_iters = {}
    pais_iters = {}
    type_deficiency_iters = {}
    renda_familiar_iters = {}
    marital_status_iters = {}
    situation_occupation_iters = {}
    staterg_iters = {}
    city_iters = {}

    user_avatar = None
    accept_first_new = False
    insert_connect_id = 0



    def __init__(self, manager, Parent=None):

        self.manager = manager
        self.users_manager = manager.users_manager
        self.occupation_manager = manager.occupation_manager
        self.address_manager = manager.address_manager
        self.city_manager = manager.city_manager

        self.insert_connect_id = self.manager.user_category_manager.connect(
                                            'insert',
                                            self.on_insert_category_user)

        self.xml = get_gtk_builder(self.ui_file)
        self.xml.connect_signals(self)

        self.users = self.xml.get_object('users')
        self.users.set_modal(True)

        self.buttonbox = self.xml.get_object("buttonbox")
        self.notes = self.xml.get_object('notes')
        self.address = self.xml.get_object('address')
        self.curriculo = self.xml.get_object('curriculo')
        self.cancel_bnt = self.xml.get_object('cancel_bnt')
        self.user_avatar_button = self.xml.get_object('user_avatar_button')
        self.user_avatar_image = self.xml.get_object('user_avatar_image')

        self.autorizoEnvio = self.xml.get_object("autorizoEnvio")

        self.ok_bnt = self.xml.get_object('ok_bnt')
        self.notesbuffer = self.notes.get_buffer()
        self.addressbuffer = self.address.get_buffer()
        self.curriculobuffer = self.curriculo.get_buffer()
        self.table2 = self.xml.get_object('table2')
        self.tableRg = self.xml.get_object('tablerg')

        self.xml.get_object('nick_status_image').set_from_file(None)

        self.birth = DateEdit.DateEdit()
        self.table2.attach(self.birth, 4, 5, 2, 3,
                           xoptions=gtk.FILL, yoptions=gtk.FILL)
        self.birth.show()

        self.data_exp = DateEdit.DateEdit()
        self.tableRg.attach(self.data_exp, 3, 4, 0, 1,
                           xoptions=gtk.FILL, yoptions=gtk.FILL)
        self.data_exp.show()

        self.xml.get_object('nick').connect_after("changed",
                                                  self.on_nick_changed)
        self._nick_timeout_id = 0

        self.reg_entry('nick')
        self.reg_entry('full_name')
        self.reg_entry('email')
        self.reg_entry('password_entry_1')
        self.reg_entry('password_entry_2')
        self.reg_entry('responsible')
        self.reg_entry('phone')
        self.reg_entry('cep')
        self.reg_entry('bairro')
        self.reg_entry('numero_ident')
        self.reg_entry('orgao_expeditor')
        self.reg_entry('cpf')


        #categories
        self.CategoryListStore = gtk.ListStore(gobject.TYPE_INT,
                                               gobject.TYPE_STRING)

        self.CategoryComboBox = gtk.ComboBox(model=self.CategoryListStore)

        cell = gtk.CellRendererText()
        self.CategoryComboBox.pack_start(cell, True)
        self.CategoryComboBox.add_attribute(cell, 'text', 1)
        self.CategoryComboBox.set_row_separator_func(self.row_separator_func)

        table = self.xml.get_object("misc_table")
        table.attach(child=self.CategoryComboBox,
                     left_attach=3,
                     right_attach=4,
                     top_attach=0,
                     bottom_attach=1,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND | gtk.FILL)

        self.xml.get_object("category_label").set_mnemonic_widget(self.CategoryComboBox)
        self.CategoryComboBox.show()

        #Populate categories
        iter = self.CategoryListStore.append((0, _("None")))
        self.category_iters[0] = iter
        self.CategoryComboBox.set_active_iter(iter)

        self.CategoryListStore.append((-1, ""))

        if self.manager:
            for i in self.manager.user_category_manager.get_all():
                iter = self.CategoryListStore.append((i.id, i.name))
                self.category_iters[i.id] = iter

        #perfil
        self.perfilListStore = gtk.ListStore(gobject.TYPE_INT,
                                               gobject.TYPE_STRING)

        self.perfilComboBox = gtk.ComboBox(model=self.perfilListStore)

        cell = gtk.CellRendererText()
        self.perfilComboBox.pack_start(cell, True)
        self.perfilComboBox.add_attribute(cell, 'text', 1)
        self.perfilComboBox.set_row_separator_func(self.row_separator_func)

        table = self.xml.get_object("table2")
        table.attach(child=self.perfilComboBox,
                     left_attach=2,
                     right_attach=3,
                     top_attach=6,
                     bottom_attach=7,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND | gtk.FILL)

        self.perfilComboBox.show()

        #Populate perfil

        self.perfilList = self.manager.perfil_manager.get_all()

        if self.manager:
            for index, perfil in enumerate(self.perfilList):
                self.perfilListStore.append((int(perfil.id),
                    perfil.perfil_description))
                #if(perfil.id == self.perfil_id):
                    #self.perfilListStore.set_active(index)


	#Create SexComboBox
	self.SexListStore = gtk.ListStore(gobject.TYPE_INT, gobject.TYPE_STRING)
        self.SexComboBox = gtk.ComboBox(model=self.SexListStore)

        cell2 = gtk.CellRendererText()
        self.SexComboBox.pack_start(cell2, True)
        self.SexComboBox.add_attribute(cell2, 'text', 1)
        self.SexComboBox.set_row_separator_func(self.row_separator_func)

        table2 = self.xml.get_object("table2")
        table2.attach(child=self.SexComboBox,
                     left_attach=4,
                     right_attach=5,
                     top_attach=1,
                     bottom_attach=2,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("sex_label").set_mnemonic_widget(self.SexComboBox)
        self.SexComboBox.show()

        #Populate genero
        iter2 = self.SexListStore.append((0, _("None")))
        self.sex_iters[0] = iter2
        self.SexComboBox.set_active_iter(iter2)

        self.SexListStore.append((1, "Feminino"))
        self.SexListStore.append((2, "Masculino"))

        #Occupation
        self.OccupationListStore = gtk.ListStore(gobject.TYPE_INT,
                                                   gobject.TYPE_STRING)

        self.OccupationComboBox = gtk.ComboBox(model=self.OccupationListStore)

        cell2 = gtk.CellRendererText()
        self.OccupationComboBox.pack_start(cell2, True)
        self.OccupationComboBox.add_attribute(cell2, 'text', 1)
        self.OccupationComboBox.set_row_separator_func(self.row_separator_func)

        table3 = self.xml.get_object("table2")
        table3.attach(child=self.OccupationComboBox,
                     left_attach=2,
                     right_attach=3,
                     top_attach=5,
                     bottom_attach=6,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("occupation_label").set_mnemonic_widget(self.OccupationComboBox)
        self.OccupationComboBox.show()

        #Populate occupation
        iter3 = self.OccupationListStore.append((0, _("None")))
        self.occupation_iters[0] = iter3
        self.OccupationComboBox.set_active_iter(iter3)

        if self.manager:
            for i in self.manager.occupation_manager.get_all():
                iter = self.OccupationListStore.append((i.id, i.description))
                self.occupation_iters[i.id] = iter

        #Etnia
        self.EtniaListStore = gtk.ListStore(gobject.TYPE_INT,
                                                   gobject.TYPE_STRING)

        self.EtniaComboBox = gtk.ComboBox(model=self.EtniaListStore)

        cell2 = gtk.CellRendererText()
        self.EtniaComboBox.pack_start(cell2, True)
        self.EtniaComboBox.add_attribute(cell2, 'text', 1)
        self.EtniaComboBox.set_row_separator_func(self.row_separator_func)

        table4 = self.xml.get_object("table2")
        table4.attach(child=self.EtniaComboBox,
                     left_attach=2,
                     right_attach=3,
                     top_attach=4,
                     bottom_attach=5,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("etnia_label").set_mnemonic_widget(self.EtniaComboBox)
        self.EtniaComboBox.show()

        #Populate etnia
        iter4 = self.EtniaListStore.append((0, _("None")))
        self.etnia_iters[0] = iter4
        self.EtniaComboBox.set_active_iter(iter4)

        if self.manager:
            for i in self.manager.etnia_manager.get_all():
                iter = self.EtniaListStore.append((i.id, i.description))
                self.etnia_iters[i.id] = iter

	#Schooling
        self.SchoolingListStore = gtk.ListStore(gobject.TYPE_INT,
                                                gobject.TYPE_STRING)

        self.SchoolingComboBox = gtk.ComboBox(model=self.SchoolingListStore)

        cell2 = gtk.CellRendererText()
        self.SchoolingComboBox.pack_start(cell2, True)
        self.SchoolingComboBox.add_attribute(cell2, 'text', 1)
        self.SchoolingComboBox.set_row_separator_func(self.row_separator_func)

        table5 = self.xml.get_object("table5")
        table5.attach(child=self.SchoolingComboBox,
                     left_attach=1,
                     right_attach=2,
                     top_attach=0,
                     bottom_attach=1,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("label_schooling").set_mnemonic_widget(self.SchoolingComboBox)
        self.SchoolingComboBox.show()

        #Populate schooling
        iter5 = self.SchoolingListStore.append((0, _("None")))
        self.schooling_iters[0] = iter5
        self.SchoolingComboBox.set_active_iter(iter5)

        if self.manager:
            for i in self.manager.schooling_manager.get_all():
                iter = self.SchoolingListStore.append((i.id, i.description))
                self.schooling_iters[i.id] = iter

        #State
        self.StateListStore = gtk.ListStore(gobject.TYPE_INT,
                                                gobject.TYPE_STRING)

        self.StateComboBox = gtk.ComboBox(model=self.StateListStore)

        cell2 = gtk.CellRendererText()
        self.StateComboBox.pack_start(cell2, True)
        self.StateComboBox.add_attribute(cell2, 'text', 1)
        self.StateComboBox.set_row_separator_func(self.row_separator_func)

        table6 = self.xml.get_object("table4")
        table6.attach(child=self.StateComboBox,
                     left_attach=1,
                     right_attach=2,
                     top_attach=0,
                     bottom_attach=1,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("label_state").set_mnemonic_widget(self.StateComboBox)
        self.StateComboBox.show()

        #Populate state
        iter6 = self.StateListStore.append((0, _("None")))
        self.state_iters[0] = iter6
        self.StateComboBox.set_active_iter(iter6)

        if self.manager:
            for i in self.manager.state_manager.get_all():
                iter = self.StateListStore.append((i.id, i.name))
                self.state_iters[i.id] = iter

	#City
        self.CityListStore = gtk.ListStore(gobject.TYPE_INT,
                                                gobject.TYPE_STRING)

        self.CityComboBox = gtk.ComboBox(model=self.CityListStore)

        cell2 = gtk.CellRendererText()
        self.CityComboBox.pack_start(cell2, True)
        self.CityComboBox.add_attribute(cell2, 'text', 1)
        self.CityComboBox.set_row_separator_func(self.row_separator_func)

        table6 = self.xml.get_object("table4")
        table6.attach(child=self.CityComboBox,
                     left_attach=3,
                     right_attach=4,
                     top_attach=0,
                     bottom_attach=1,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("label_city").set_mnemonic_widget(self.CityComboBox)
        self.CityComboBox.show()
	iter6 = self.CityListStore.append((0, _("None")))
	self.city_iters[0] = iter6
	self.CityComboBox.set_active_iter(iter6)
        #self.CityComboBox.set_sensitive(0)




	#State RG
        self.StateRgListStore = gtk.ListStore(gobject.TYPE_INT,
                                                gobject.TYPE_STRING)

        self.StateRgComboBox = gtk.ComboBox(model=self.StateRgListStore)

        cell2 = gtk.CellRendererText()
        self.StateRgComboBox.pack_start(cell2, True)
        self.StateRgComboBox.add_attribute(cell2, 'text', 1)
        self.StateRgComboBox.set_row_separator_func(self.row_separator_func)

        tableRg = self.xml.get_object("tablerg")
        tableRg.attach(child=self.StateRgComboBox,
                     left_attach=3,
                     right_attach=4,
                     top_attach=1,
                     bottom_attach=2,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("labelStateRg").set_mnemonic_widget(self.StateRgComboBox)
        self.StateRgComboBox.show()

        #Populate state rg
        iterRg = self.StateRgListStore.append((0, _("None")))
        self.staterg_iters[0] = iterRg
        self.StateRgComboBox.set_active_iter(iterRg)

        if self.manager:
            for i in self.manager.state_manager.get_all():
                iter = self.StateRgListStore.append((i.id, i.name))
                self.staterg_iters[i.id] = iter


	#Pais
        self.PaisListStore = gtk.ListStore(gobject.TYPE_INT,
                                                gobject.TYPE_STRING)

        self.PaisComboBox = gtk.ComboBox(model=self.PaisListStore)

        cell2 = gtk.CellRendererText()
        self.PaisComboBox.pack_start(cell2, True)
        self.PaisComboBox.add_attribute(cell2, 'text', 1)
        self.PaisComboBox.set_row_separator_func(self.row_separator_func)

        table7 = self.xml.get_object("table4")
        table7.attach(child=self.PaisComboBox,
                     left_attach=5,
                     right_attach=6,
                     top_attach=0,
                     bottom_attach=1,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("label_pais").set_mnemonic_widget(self.PaisComboBox)
        self.PaisComboBox.show()

        #Populate pais
        iter6 = self.PaisListStore.append((0, _("None")))
        self.pais_iters[0] = iter6
        self.PaisComboBox.set_active_iter(iter6)

        if self.manager:
            for i in self.manager.pais_manager.get_all():
                iter = self.PaisListStore.append((i.id, i.description))
                self.pais_iters[i.id] = iter

        #Type Deficiency
        self.TypeDeficiencyListStore = gtk.ListStore(gobject.TYPE_INT,
                                                gobject.TYPE_STRING)

        self.TypeDeficiencyComboBox = gtk.ComboBox(model=self.TypeDeficiencyListStore)

        cell2 = gtk.CellRendererText()
        self.TypeDeficiencyComboBox.pack_start(cell2, True)
        self.TypeDeficiencyComboBox.add_attribute(cell2, 'text', 1)
        self.TypeDeficiencyComboBox.set_row_separator_func(self.row_separator_func)

        table8 = self.xml.get_object("table2")
        table8.attach(child=self.TypeDeficiencyComboBox,
                     left_attach=2,
                     right_attach=3,
                     top_attach=3,
                     bottom_attach=4,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("deficiencia_label").set_mnemonic_widget(self.TypeDeficiencyComboBox)
        self.TypeDeficiencyComboBox.show()

        #Populate Type Deficiency
        iter7 = self.TypeDeficiencyListStore.append((0, _("None")))
        self.type_deficiency_iters[0] = iter7
        self.TypeDeficiencyComboBox.set_active_iter(iter7)

        if self.manager:
            for i in self.manager.type_deficiency_manager.get_all():
                iter = self.TypeDeficiencyListStore.append((i.id, i.description))
                self.type_deficiency_iters[i.id] = iter

	#Renda Familiar
        self.RendaFamiliarListStore = gtk.ListStore(gobject.TYPE_INT,
                                                gobject.TYPE_STRING)

        self.RendaFamiliarComboBox = gtk.ComboBox(model=self.RendaFamiliarListStore)

        cell2 = gtk.CellRendererText()
        self.RendaFamiliarComboBox.pack_start(cell2, True)
        self.RendaFamiliarComboBox.add_attribute(cell2, 'text', 1)
        self.RendaFamiliarComboBox.set_row_separator_func(self.row_separator_func)

        table9 = self.xml.get_object("table2")
        table9.attach(child=self.RendaFamiliarComboBox,
                     left_attach=4,
                     right_attach=5,
                     top_attach=4,
                     bottom_attach=5,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("renda_label").set_mnemonic_widget(self.RendaFamiliarComboBox)
        self.RendaFamiliarComboBox.show()

        #Populate Renda Familiar
        iter8 = self.RendaFamiliarListStore.append((0, _("None")))
        self.renda_familiar_iters[0] = iter8
        self.RendaFamiliarComboBox.set_active_iter(iter8)

        if self.manager:
            for i in self.manager.renda_familiar_manager.get_all():
                iter = self.RendaFamiliarListStore.append((i.id, i.description))
                self.renda_familiar_iters[i.id] = iter

        #Marital Status
        self.MaritalStatusListStore = gtk.ListStore(gobject.TYPE_INT,
                                                gobject.TYPE_STRING)

        self.MaritalStatusComboBox = gtk.ComboBox(model=self.MaritalStatusListStore)

        cell2 = gtk.CellRendererText()
        self.MaritalStatusComboBox.pack_start(cell2, True)
        self.MaritalStatusComboBox.add_attribute(cell2, 'text', 1)
        self.MaritalStatusComboBox.set_row_separator_func(self.row_separator_func)

        table10 = self.xml.get_object("table2")
        table10.attach(child=self.MaritalStatusComboBox,
                     left_attach=4,
                     right_attach=5,
                     top_attach=3,
                     bottom_attach=4,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("marital_label").set_mnemonic_widget(self.MaritalStatusComboBox)
        self.MaritalStatusComboBox.show()

        #Populate Marital Status
        iter9 = self.MaritalStatusListStore.append((0, _("None")))
        self.marital_status_iters[0] = iter9
        self.MaritalStatusComboBox.set_active_iter(iter9)

        if self.manager:
            for i in self.manager.marital_status_manager.get_all():
                iter = self.MaritalStatusListStore.append((i.id, i.description))
                self.marital_status_iters[i.id] = iter

        #Situation Occupation
        self.SituationOccupationListStore = gtk.ListStore(gobject.TYPE_INT,
                                                gobject.TYPE_STRING)

        self.SituationOccupationComboBox = gtk.ComboBox(model=self.SituationOccupationListStore)

        cell2 = gtk.CellRendererText()
        self.SituationOccupationComboBox.pack_start(cell2, True)
        self.SituationOccupationComboBox.add_attribute(cell2, 'text', 1)
        self.SituationOccupationComboBox.set_row_separator_func(self.row_separator_func)

        table11 = self.xml.get_object("table2")
        table11.attach(child=self.SituationOccupationComboBox,
                     left_attach=4,
                     right_attach=5,
                     top_attach=5,
                     bottom_attach=6,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("situation_label").set_mnemonic_widget(self.SituationOccupationComboBox)
        self.SituationOccupationComboBox.show()

        #Populate Situation Occupation
        iter10 = self.SituationOccupationListStore.append((0, _("None")))
        self.situation_occupation_iters[0] = iter10
        self.SituationOccupationComboBox.set_active_iter(iter10)

        if self.manager:
            for i in self.manager.situation_occupation_manager.get_all():
                iter = self.SituationOccupationListStore.append((i.id, i.description))
                self.situation_occupation_iters[i.id] = iter


	self.StateComboBox.connect('changed', self.on_state_combobox_changed)

        if Parent:
            self.users.set_transient_for(Parent)


    def on_state_combobox_changed(self, box):
        model = box.get_model()
        index = box.get_active()
        if index:
	    self.CityListStore.clear()
	    #self.CityComboBox.set_sensitive(1)
            #Populate city
	    iter6 = self.CityListStore.append((0, _("None")))
	    self.city_iters[0] = iter6
	    self.CityComboBox.set_active_iter(iter6)
		
	    if self.manager:
	       for i in self.manager.city_manager.get_lista_cidades(model[index][0]):
		   iter = self.CityListStore.append((i.id, i.name))
		   self.city_iters[i.id] = iter


    def connect(self):

        self.input['nick'].connect("changed", self.check_obj, 'nick')
        self.input['full_name'].connect("changed", self.check_obj, 'full_name')
	self.input['email'].connect("changed", self.check_obj, 'email')
	if not self.user_t:
	   self.input['password_entry_1'].connect("changed", self.check_obj, 'password_entry_1')
	   self.input['password_entry_2'].connect("changed", self.check_obj, 'password_entry_2')

	self.input['cpf'].connect("changed", self.check_obj, 'cpf')
	self.input['cep'].connect("changed", self.check_obj, 'cep')
	

    def reg_entry(self, name):

        widget = self.xml.get_object(name)
        self.data[name] = ""
        self.input[name] = widget

        return widget

	

    def on_nick_changed_done(self):
        nick_widget = self.xml.get_object('nick')

        if not nick_widget:
            return

        nick = nick_widget.get_text()
        obj = self.xml.get_object('nick_status_image')
        nick_alert_hbox = self.xml.get_object('nick_alert_hbox')

        if (nick != "" and
           (MIN_NICK <= len(nick) <= MAX_NICK) and
            nick != self.data['nick']):

            if self.users_manager.get_all().filter_by(nick=nick).count() == 1:
                self.nick_found = True
                stock = gtk.STOCK_CANCEL
                nick_alert_hbox.show()
            else:
                self.nick_found = False
                stock = gtk.STOCK_APPLY
                nick_alert_hbox.hide()

            obj.set_from_stock(stock, gtk.ICON_SIZE_MENU)

        else:
            self.nick_found = False
            obj.set_from_file(None)

        self.check_forward_button()

    def check_forward_button(self):
        t = not(bool([i for i in self.faults, self.errs, self.warns if i]))
        self.ok_bnt.set_sensitive(t and not(self.nick_found))

    def on_insert_category_user(self, manager, category):
        iter = self.CategoryListStore.append((category.id, category.name))
        self.category_iters[category.id] = iter

        if self.accept_first_new:
            self.CategoryComboBox.set_active_iter(iter)

    def on_nick_insert_text(self, obj, new_str, length, position):

        position = obj.get_position()

        if new_str.isalpha() and new_str.isupper():
            obj.stop_emission('insert-text')
            obj.insert_text(new_str.lower(), position)
            gobject.idle_add(obj.set_position, position+1)

        elif new_str.isdigit() or new_str.islower():
            return
        else:
            obj.stop_emission('insert-text')

    def on_nick_changed(self, obj):

        if self._nick_timeout_id > 0:
            gobject.source_remove(self._nick_timeout_id)

        timeout = 1000

        self._nick_timeout_id = gobject.timeout_add(timeout,
                                    self.on_nick_changed_done)

    def on_user_avatar_clicked(self, obj):
        dlg = ImageChooserDialog()
        response, image_file = dlg.run()

        if response == gtk.RESPONSE_NONE:
            self.user_avatar = None
            self.user_avatar_image.set_from_icon_name("stock_person", 6)

            #Remove Avatar File
            if user_has_avatar(self.data['id']):
                try:
                    os_remove(get_user_avatar_path(self.data['id']))
                except Exception , e:
                    print str(e)


        if response == gtk.RESPONSE_OK:
            self.user_avatar = image_file

            pixbuf = gtk.gdk.pixbuf_new_from_file(image_file)

            if not pixbuf:
                return

            #Calculate resize
            height = pixbuf.get_height()
            width = pixbuf.get_width()

            k = width / 64.0
            l = height / 94.0

            if k >= l:
                x = 64
                y = height / k
            else:
                x = width / l
                y = 94

            pixbuf = pixbuf.scale_simple(int(x), int(y), gtk.gdk.INTERP_TILES)
            self.user_avatar_image.set_from_pixbuf(pixbuf)

    def reset_data(self):
	for key in self.input.keys():
	    if key != "password_entry_1" and key != "password_entry_2" and key != "autorizoEnvio":
	       self.data[key] = ""
               self.input[key].set_text("")

        self.data['notes'] = ""
        self.data['address'] = ""
        self.data['curriculo'] = ""
        self.data['birth'] = None
	self.data['data_expedicao'] = None

        self.notesbuffer.set_text("")
        self.birth.set_properties('initial-time', (time.time(),))
	self.data_exp.set_properties('initial-time', (time.time(),))

    def set_data(self, user, address, registro_geral):

        self.reset_data()

        for key in self.input:

            if key != "city" and key != "cep" and key != "bairro" and key != "cpf" and key != "numero_ident" and key != "orgao_expeditor" and key != "password_entry_1" and key != "password_entry_2":
                value = user.__getattribute__(key)

                if value:
                    self.data[key] = value
                    self.input[key].set_text(self.data[key])
	
        if registro_geral.numero_ident:
            self.data['numero_ident'] = registro_geral.numero_ident
            self.input['numero_ident'].set_text(self.data['numero_ident'])

	if registro_geral.orgao_expeditor:
            self.data['orgao_expeditor'] = registro_geral.orgao_expeditor
            self.input['orgao_expeditor'].set_text(self.data['orgao_expeditor'])

	if registro_geral.state:
            if registro_geral.state in self.staterg_iters:
               iterRg = self.staterg_iters[registro_geral.state]
               self.StateRgComboBox.set_active_iter(iterRg)	
	
	if user.cpf:
	   cpf = CPF(user.cpf)
	   self.data['cpf'] = cpf.__str__()
	   self.input['cpf'].set_text(self.data['cpf'])


        if address.cep:
            self.data['cep'] = address.cep
            self.input['cep'].set_text(self.data['cep'])

        if address.bairro:
            self.data['bairro'] = address.bairro
            self.input['bairro'].set_text(self.data['bairro'])

        if user.notes:
            self.data['notes'] = user.notes
            self.notesbuffer.set_text(self.data['notes'])

        if address.address:
            self.data['address'] = address.address
            self.addressbuffer.set_text(self.data['address'])
	
        if address.state:
            if address.state in self.state_iters:
               iter6 = self.state_iters[address.state]
               self.StateComboBox.set_active_iter(iter6)

	if address.city:
	    for i in self.manager.city_manager.get_lista_cidades(address.state):
		   iter = self.CityListStore.append((i.id, i.name))
		   self.city_iters[i.id] = iter

	    iter6 = self.city_iters[address.city]
            self.CityComboBox.set_active_iter(iter6)


        if address.pais:
            if address.pais in self.pais_iters:
               iter7 = self.pais_iters[address.pais]
               self.PaisComboBox.set_active_iter(iter7)

        if address.id:
            self.data['id_address'] = address.id

        if user.curriculo:
            self.data['curriculo'] = user.curriculo
            self.curriculobuffer.set_text(self.data['curriculo'])

        if user.birth:
            self.data['birth'] = user.birth
            self.birth.set_time(map(int, self.data['birth'].split('-')))

	if registro_geral.date_expedicao:
            self.data['data_expedicao'] = registro_geral.date_expedicao
	    self.data_exp.set_time(map(int, self.data['data_expedicao'].split('-')))

	
        self.data['category_id'] = user.category_id

        if user.category_id:
            if user.category_id in self.category_iters:
                iter = self.category_iters[user.category_id]
                self.CategoryComboBox.set_active_iter(iter)

	self.autorizoEnvio.set_active(user.autorizoEnvio)

        if user.sex:
            if user.sex in self.sex_iters:
                iter2 = self.sex_iters[user.sex]
                self.SexComboBox.set_active_iter(iter2)

        if user.occupation:
            if user.occupation in self.occupation_iters:
                iter3 = self.occupation_iters[user.occupation]
                self.OccupationComboBox.set_active_iter(iter3)

        if user.etnia:
            if user.etnia in self.etnia_iters:
                iter4 = self.etnia_iters[user.etnia]
                self.EtniaComboBox.set_active_iter(iter4)

        if user.schooling:
            if user.schooling in self.schooling_iters:
                iter5 = self.schooling_iters[user.schooling]
                self.SchoolingComboBox.set_active_iter(iter5)

        if user.type_deficiency:
            if user.type_deficiency in self.type_deficiency_iters:
                iter8 = self.type_deficiency_iters[user.type_deficiency]
                self.TypeDeficiencyComboBox.set_active_iter(iter8)

        if user.renda_familiar:
            if user.renda_familiar in self.renda_familiar_iters:
                iter9 = self.renda_familiar_iters[user.renda_familiar]
                self.RendaFamiliarComboBox.set_active_iter(iter9)

        if user.marital_status:
            if user.marital_status in self.marital_status_iters:
                iter10 = self.marital_status_iters[user.marital_status]
                self.MaritalStatusComboBox.set_active_iter(iter10)

        if user.situation_occupation:
            if user.situation_occupation in self.situation_occupation_iters:
                iter11 = self.situation_occupation_iters[user.situation_occupation]
                self.SituationOccupationComboBox.set_active_iter(iter11)


        self.data['id'] = user.id
        self.data['user'] = user.id
        self.data['rg_user'] = user.id

        if user_has_avatar(user.id):
            self.user_avatar_image.set_from_file(get_user_avatar_path(user.id))

        ###perfil
        self.perfil_id = self.manager.perfil_user_manager.get_perfilId_by_userId(
            user.id)

        self.user_perfil = self.manager.perfil_user_manager.get_PerfilUser_by_userId(
            user.id)

        for index, perfil in enumerate(self.perfilList):
            if(perfil.id == self.perfil_id):
                self.perfilComboBox.set_active(index)

    def get_data(self):

        newdata = {}
        bf = self.notesbuffer
        newdata['notes'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())

        bf = self.addressbuffer
        newdata['address'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())

        bf = self.curriculobuffer
        newdata['curriculo'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())

        newdata['birth'] = '%s-%s-%s' % self.birth.get_time()

	newdata['data_expedicao'] = '%s-%s-%s' % self.data_exp.get_time()

        iter = self.CategoryComboBox.get_active_iter()
        id_category = self.CategoryListStore.get_value(iter, 0)
        if (id_category == 0 or id_category == -1):
            newdata['category_id'] = None
        else:
            newdata['category_id'] = id_category

        iter2 = self.SexComboBox.get_active_iter()
        id_sex = self.SexListStore.get_value(iter2, 0)
        if (id_sex == 0):
            newdata['sex'] = None
        else:
            newdata['sex'] = id_sex

        iter3 = self.OccupationComboBox.get_active_iter()
        id_occupation = self.OccupationListStore.get_value(iter3, 0)
        if (id_occupation == 0):
            newdata['occupation'] = None
        else:
            newdata['occupation'] = id_occupation

        iter4 = self.EtniaComboBox.get_active_iter()
        id_etnia = self.EtniaListStore.get_value(iter4, 0)
        if (id_etnia == 0):
            newdata['etnia'] = None
        else:
            newdata['etnia'] = id_etnia

        iter5 = self.SchoolingComboBox.get_active_iter()
        id_schooling = self.SchoolingListStore.get_value(iter5, 0)
        if (id_schooling == 0):
            newdata['schooling'] = None
        else:
            newdata['schooling'] = id_schooling

        iterRg = self.StateRgComboBox.get_active_iter()
        id_state_rg = self.StateRgListStore.get_value(iterRg, 0)
        if (id_state_rg == 0):
            newdata['staterg'] = None
        else:
            newdata['staterg'] = id_state_rg

	iter6 = self.StateComboBox.get_active_iter()
        id_state = self.StateListStore.get_value(iter6, 0)
        if (id_state == 0):
            newdata['state'] = None
        else:
            newdata['state'] = id_state

	iter6 = self.CityComboBox.get_active_iter()
        id_city = self.CityListStore.get_value(iter6, 0)
        if (id_city == 0):
            newdata['city'] = None
        else:
            newdata['city'] = id_city
	
        iter7 = self.PaisComboBox.get_active_iter()
        id_pais = self.PaisListStore.get_value(iter7, 0)
        if (id_pais == 0):
            newdata['pais'] = None
        else:
            newdata['pais'] = id_pais

        iter8 = self.TypeDeficiencyComboBox.get_active_iter()
        id_type_deficiency = self.TypeDeficiencyListStore.get_value(iter8, 0)
        if (id_type_deficiency == 0):
            newdata['type_deficiency'] = None
        else:
            newdata['type_deficiency'] = id_type_deficiency

        iter9 = self.RendaFamiliarComboBox.get_active_iter()
        id_renda_familiar = self.RendaFamiliarListStore.get_value(iter9, 0)
        if (id_renda_familiar == 0):
            newdata['renda_familiar'] = None
        else:
            newdata['renda_familiar'] = id_renda_familiar

        iter10 = self.MaritalStatusComboBox.get_active_iter()
        id_marital_status = self.MaritalStatusListStore.get_value(iter10, 0)
        if (id_marital_status == 0):
            newdata['marital_status'] = None
        else:
            newdata['marital_status'] = id_marital_status

        iter11 = self.SituationOccupationComboBox.get_active_iter()
        id_situation_occupation = self.SituationOccupationListStore.get_value(iter11, 0)
        if (id_situation_occupation == 0):
            newdata['situation_occupation'] = None
        else:
            newdata['situation_occupation'] = id_situation_occupation

        for key in self.input.keys():
	    if key != "password_entry_1" and key != "password_entry_2":
               newdata[key] = self.input[key].get_text()

        return newdata

    def get_new_data(self):

        new = self.get_data()

        def f(x):
            return x[1] != self.data[x[0]]

        return dict(filter(f, zip(new.keys(), new.values())))

    def row_separator_func(self, model, iter):

        if model.get_value(iter, 0) == -1:
            return True
        else:
            return False

    def on_new_category_clicked(self, obj):
        if self.manager:
            self.accept_first_new = True
            self.manager.add_new_user_category_clicked(None)
            self.accept_first_new = False

    def run(self, user=None, address=None, registro_geral=None):

        nick_ant = ""
	self.user_t = user
        if user:
	    nick_ant = user.nick
            self.set_data(user, address, registro_geral)
        else:
            self.ok_bnt.set_sensitive(False)
            self.faults = ['nick', 'full_name', 'email', 'password_entry_1', 'password_entry_2']

        self.connect()
        response = self.users.run()

        if response == 0:
            data = self.get_new_data()

            for key, value in data.items():

                if key == "city" or key == "user" or key == "state" or key == "pais" or key == "address" or key == "cep" or key == "bairro":
                    address.__setattr__(key, value)
                elif key == "id_address":
                    address.id = value
                elif key == "numero_ident" or key == "orgao_expeditor":
                    registro_geral.__setattr__(key, value)
                elif key == "rg_user":
                    registro_geral.user = value
		elif key == "staterg":
                    registro_geral.state = value
                else:
                    user.__setattr__(key, value)

            user.alterado = True
            user.logado = False
	    user.autorizoEnvio = self.autorizoEnvio.get_active()

            if address.id:
                self.address_manager.update(address)
            elif (address.city or address.state or address.pais or address.cep or address.bairro or address.address):
		address.user = user.id
                self.address_manager.insert(address)

            registro_geral.user = user.id

            if registro_geral.id:
                self.manager.registro_geral_manager.update(registro_geral)
            elif (registro_geral.numero_ident):
                self.manager.registro_geral_manager.insert(registro_geral)

            self.users_manager.update(user)
	    if nick_ant != user.nick:
	       os.system(("usermod -l %s") % user.nick)

            #perfil
            index_perfil_selected = self.perfilComboBox.get_active()
            if(index_perfil_selected == -1):
                ok_only(_("<b><big>É necesssário escolher um perfil para o usuário.</big></b>\n\n"), Parent=None, ICON=gtk.MESSAGE_ERROR)
            perfil = self.perfilList[index_perfil_selected]
            perfil_user = Perfil_User(user.id, perfil.id)
            if self.user_perfil:
                self.manager.perfil_user_manager.delete_by_id(self.user_perfil.id)
            self.manager.perfil_user_manager.insert(perfil_user)

            #Avatar
            try:
                avatar_pixbuf = self.user_avatar_image.get_pixbuf()
            except ValueError:
                avatar_pixbuf = None

            if self.user_avatar and avatar_pixbuf:
                path = get_user_avatar_path(user.id)

                try:
                    avatar_pixbuf.save(path, "png")
                except Exception, error:
                    print error

            #Remove Callback
            if self.insert_connect_id:
                gobject.source_remove(self.insert_connect_id)
                self.insert_connect_id = 0

        self.users.destroy()

    def check_obj(self, obj, name):
        """
            Check gtk.Entries is Valid
        """

        text = obj.get_text()

        objs = {
                'nick': check_nick,
                'full_name': check_name,
		'email': check_email,
		'password_entry_1': check_password,
		'password_entry_2': check_confirm_password,
		#'cpf': check_cpf,
		'cep': check_cep
               }

        for i in [self.faults, self.warns, self.errs]:
            if name in i:
                i.remove(name)

        tmp = objs[name](text)

        ## Check order
        ## 0 = OK
        ## 1 = Fault
        ## 2 = Warning
        ## 3 = Error

        if tmp == 1:
            self.faults.append(name)
        elif tmp == 3:
            self.errs.append(name)
            color_entry(obj, COLOR_YELLOW)
        elif tmp == 2:
            self.warns.append(name)
            color_entry(obj, COLOR_RED)
        else:
            color_entry(obj)

        t = not(bool([i for i in self.faults, self.errs, self.warns if i]))
        self.ok_bnt.set_sensitive(t and not(self.nick_found))

class add_schedule:

    faults = ['comment']
    users_iters = {}
    input = {}
    schedule_of_borrow = None
    user = None
    borrowed_date = None

    data = {}
    data['id_user'] = 0
    data['responsible_user'] = ""
    data['return_date'] = datetime.datetime.now()
    data['comment'] = ""


    def __init__(self, manager, Parent=None):

        self.manager = manager
        self.list_bens_manager = self.manager.list_bens_manager
        self.users_manager = self.manager.users_manager
        self.schedule_manager = self.manager.schedule_manager

        self.xml = get_gtk_builder('add_schedule')
        self.add_schedule = self.xml.get_object('add_schedule')

        self.apply_bnt = self.xml.get_object('apply_bnt')
        self.comment = self.xml.get_object('comment')
	
        self.comment_buffer = self.comment.get_buffer()
        self.cancel_bnt = self.xml.get_object('cancel_bnt')
        self.table = self.xml.get_object("table1")

        self.return_date = DateEdit.DateEdit()
        self.table.attach(self.return_date, 1, 2, 2, 3,
                           xoptions=gtk.FILL, yoptions=gtk.FILL)
        self.return_date.show()

        self.UsuarioListStore = gtk.ListStore(gobject.TYPE_INT,
                                               gobject.TYPE_STRING)

        self.UsuarioComboBox = gtk.ComboBox(model=self.UsuarioListStore)

        cell = gtk.CellRendererText()
        self.UsuarioComboBox.pack_start(cell, True)
        self.UsuarioComboBox.add_attribute(cell, 'text', 1)
        self.UsuarioComboBox.set_row_separator_func(self.row_separator_func)


        self.table.attach(child=self.UsuarioComboBox,
                     left_attach=1,
                     right_attach=2,
                     top_attach=1,
                     bottom_attach=2,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("label3").set_mnemonic_widget(self.UsuarioComboBox)
        self.UsuarioComboBox.show()


        if self.manager:
            for i in self.users_manager.get_all():
                try:
                    self.manager.users_block_borrow_manager.get_all().filter_by(user=i.id).one()
                except:
                    iter = self.UsuarioListStore.append((i.id, i.nick))
                    self.users_iters[i.id] = iter

        self.xml.connect_signals(self)

	self.reg_entry("responsible_user")

        self.cancel_bnt = gtk.Button(stock=gtk.STOCK_CANCEL)
        self.cancel_bnt.connect("clicked", self.on_cancel_button_clicked)

        self.apply_bnt = gtk.Button(stock=gtk.STOCK_SAVE)
        self.apply_bnt.set_sensitive(False)
        self.apply_bnt.connect("clicked", self.on_apply_bnt_clicked)
        self.apply_bnt.set_no_show_all(True)

        if Parent:
            self.add_schedule.set_transient_for(Parent)

    def row_separator_func(self, model, iter):

        if model.get_value(iter, 0) == -1:
            return True
        else:
            return False

    def reg_entry(self, name):

        widget = self.xml.get_object(name)
        self.data[name] = ""
        self.input[name] = widget

        return widget

    def get_data(self):

	newdata = {}	

	iter = self.UsuarioComboBox.get_active_iter()
        if iter:
            newdata['id_user'] = self.UsuarioListStore.get_value(iter, 0)
        else:
            ok_only(_("<b><big>É necesssário escolher o usuario.</big></b>\n\n"
                      "Caso nao tenha nenhum usuario cadastrado, realize o cadastro antes de realizar o empréstimo."),
                      Parent=None, ICON=gtk.MESSAGE_ERROR)

            return

	for key in self.input.keys():
            newdata[key] = self.input[key].get_text()
	
	newdata['return_date'] = '%s-%s-%s' % self.return_date.get_time()


        bf = self.comment_buffer
        newdata['comment'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())


        return newdata

    def get_new_data(self):

        new = self.get_data()

        def f(x):
            return x[1] != self.data[x[0]]

        return dict(filter(f, zip(new.keys(), new.values())))


    def on_cancel_button_clicked(self, obj):
        self.add_schedule.destroy()

    def on_apply_bnt_clicked(self, obj):
        data = self.get_new_data()

        if data:

            schedule = ScheduleOfBorrow()

	    for key, value in data.items():
		schedule.__setattr__(key, value)

            try:
		reserveOb = ReserveOfBorrow()
		reserve = self.manager.reserve_manager.get_next_user(self.heritage.id)

                if reserve.id_user == schedule.id_user:
                   self.manager.reserve_manager.delete_by_id(reserve.id)
		   self.heritage.reserve_id = None


		   schedule.borrowed_date = datetime.datetime.now()
                   schedule.name_heritage = self.heritage.name

                   self.schedule_manager.insert(schedule)
                   schedule_id = self.schedule_manager.get_all().filter_by(borrowed_date=schedule.borrowed_date).one()

                   if schedule_id:
                      self.heritage.borrow_id = schedule_id.id

                      self.list_bens_manager.update(self.heritage)

                      self.add_schedule.destroy()


                else:
                    ok_only(_("<b><big>Nao foi possivel realizar emprestimo.</big></b>\n\n"
                              "Este material possui reserva para outro usuario. \n\n Aguarde sua vez."),
                               Parent=None, ICON=gtk.MESSAGE_ERROR)

                    return

            except Exception, error:
		
		schedule.borrowed_date = datetime.datetime.now()
                schedule.name_heritage = self.heritage.name

                self.schedule_manager.insert(schedule)

                schedule_id = self.schedule_manager.get_all().filter_by(borrowed_date=schedule.borrowed_date).one()

                if schedule_id:
                    self.heritage.borrow_id = schedule_id.id

                    self.list_bens_manager.update(self.heritage)

                    self.add_schedule.destroy()



    def run(self, heritage):

        self.heritage = heritage

        self.add_schedule.show()


###BSI
class authentication_dialog:

    def __init__(self, manager):
        self.manager = manager

    def run(self):
        self.xml = get_gtk_builder('autenticacao')
        self.autenticacao = self.xml.get_object('autenticacao')
        self.xml.connect_signals(self)
        self.autenticacao.show_all()

    def on_delete(self, *args):
        dlg = exit(_('<big><b>Are you sure you want to quit?'
                                 '</b></big>'),
                               Parent=self.autenticacao, allow_miminize=False)
        if dlg.response == gtk.RESPONSE_YES:
            self.manager.save_window_positions()
            self.manager.desabilitar_proxy()
            gtk.main_quit()

        return True

    def on_apply_bnt_clicked(self, obj):
        usuario_input = self.xml.get_object("entry1")
        senha_input = self.xml.get_object("entry2")
        result = self.manager.users_manager.check_user(usuario_input.get_text(), md5_cripto(senha_input.get_text()))
        if not result:
            ok_only(_("<b><big>Usuário ou senha inválidos.</big></b>\n\n"), Parent=None, ICON=gtk.MESSAGE_ERROR)
            return True
        user_id = result['id']
        user = self.manager.users_manager.get_all().filter_by(id=user_id).one()
        perfil_id = self.manager.perfil_user_manager.get_perfilId_by_userId(user_id)
        perfil_action_list = self.manager.perfil_action_manager.get_perfil_actions_by_perfil_id(perfil_id)
        self.manager.current_user = user
        self.manager.current_user_credentials = perfil_action_list
        self.autenticacao.destroy()
        ok_only("Bem vindo, %s." % user.full_name, Parent=None)
        return True


class change_perfil:

    def __init__(self, user_id, manager):
        self.user_id = user_id
        self.manager = manager
        self.selected_user = self.manager.users_manager.get_all().filter_by(
            id=self.user_id).one()
        self.perfilList = self.manager.perfil_manager.get_all()
        self.perfil_id = self.manager.perfil_user_manager.get_perfilId_by_userId(
            self.selected_user.id)
        self.user_perfil = self.manager.perfil_user_manager.get_PerfilUser_by_userId(
            self.selected_user.id)

    def run(self):

        self.xml = get_gtk_builder('change_perfil')
        self.change_perfil = self.xml.get_object('change_perfil')
        self.cancel_bnt = self.xml.get_object('cancel_bnt')
        self.xml.connect_signals(self)
        self.cancel_bnt = gtk.Button(stock=gtk.STOCK_CANCEL)
        self.cancel_bnt.connect("clicked", self.on_cancel_button_clicked)

        table = self.xml.get_object("table1")

        labelUsuario = gtk.Label()
        labelUsuario.set_markup("<b>Usuário: </b>")
        labelUsuario.set_alignment(0, 0.5)
        table.attach(labelUsuario, 0, 1, 0, 1)
        labelUsuario.show()

        valorUsuario = gtk.Label()
        valorUsuario.set_markup(str(self.selected_user.nick))
        valorUsuario.set_alignment(0, 0.5)
        table.attach(valorUsuario, 1, 2, 0, 1)
        valorUsuario.show()

        labelUsuario = gtk.Label()
        labelUsuario.set_markup("<b>Nome: </b>")
        labelUsuario.set_alignment(0, 0.5)
        table.attach(labelUsuario, 0, 1, 1, 2)
        labelUsuario.show()

        valorUsuario = gtk.Label()
        valorUsuario.set_markup(str(self.selected_user.full_name))
        valorUsuario.set_alignment(0, 0.5)
        table.attach(valorUsuario, 1, 2, 1, 2)
        valorUsuario.show()

        labelUsuario = gtk.Label()
        labelUsuario.set_markup("<b>CPF: </b>")
        labelUsuario.set_alignment(0, 0.5)
        table.attach(labelUsuario, 0, 1, 2, 3)
        labelUsuario.show()

        valorUsuario = gtk.Label()
        valorUsuario.set_markup(str(self.selected_user.cpf) if self.selected_user.cpf else "Não informado")
        valorUsuario.set_alignment(0, 0.5)
        table.attach(valorUsuario, 1, 2, 2, 3)
        valorUsuario.show()

        labelUsuario = gtk.Label()
        labelUsuario.set_markup("<b>RG: </b>")
        labelUsuario.set_alignment(0, 0.5)
        table.attach(labelUsuario, 0, 1, 3, 4)
        labelUsuario.show()

        valorUsuario = gtk.Label()
        rg = RegistroGeral()
        rows = self.manager.registro_geral_manager.get_all()
        try:
            rg = rows.filter_by(user=self.user_id).one()
        except:
            pass

        valorUsuario.set_markup(str(rg.numero_ident) if rg.numero_ident else "Não informado")
        valorUsuario.set_alignment(0, 0.5)
        table.attach(valorUsuario, 1, 2, 3, 4)
        valorUsuario.show()

        labelUsuario = gtk.Label()
        labelUsuario.set_markup("<b>Perfil: </b>")
        labelUsuario.set_alignment(0, 0.5)
        table.attach(labelUsuario, 0, 1, 4, 5)
        labelUsuario.show()

        self.PerfilListStore = gtk.ListStore(gobject.TYPE_INT,
            gobject.TYPE_STRING)
        self.PerfilComboBox = gtk.ComboBox(model=self.PerfilListStore)

        cell = gtk.CellRendererText()
        self.PerfilComboBox.pack_start(cell, True)
        self.PerfilComboBox.add_attribute(cell, 'text', 1)
        self.PerfilComboBox.set_row_separator_func(self.row_separator_func)

        table.attach(child=self.PerfilComboBox,
                     left_attach=1,
                     right_attach=2,
                     top_attach=4,
                     bottom_attach=5,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND | gtk.FILL)
        self.PerfilComboBox.show()

        for index, perfil in enumerate(self.perfilList):
            self.PerfilListStore.append((int(perfil.id),
                perfil.perfil_description))
            if(perfil.id == self.perfil_id):
                self.PerfilComboBox.set_active(index)

        table.show()

        self.change_perfil.show()

    def on_cancel_button_clicked(self, obj):
        self.change_perfil.destroy()

    def row_separator_func(self, model, iter):
        if model.get_value(iter, 0) == -1:
            return True
        else:
            return False

    def on_apply_bnt_clicked(self, obj):
        index_perfil_selected = self.PerfilComboBox.get_active()
        if(index_perfil_selected == -1):
            ok_only(_("<b><big>É necesssário escolher um perfil para o usuário.</big></b>\n\n"), Parent=None, ICON=gtk.MESSAGE_ERROR)
        perfil = self.perfilList[index_perfil_selected]
        perfil_user = Perfil_User(self.selected_user.id, perfil.id)
        if self.user_perfil:
            self.manager.perfil_user_manager.delete_by_id(self.user_perfil.id)
        self.manager.perfil_user_manager.insert(perfil_user)

        if (self.selected_user.id == self.manager.current_user.id):
            self.manager.user_credentials = self.manager.perfil_action_manager.get_perfil_actions_by_perfil_id(perfil.id)

        self.change_perfil.destroy()


class config_perfil:

    def __init__(self, manager, perfil_id=1):
        self.manager = manager
        self.perfil_id = perfil_id
        self.selected_perfil = self.manager.perfil_manager.get_all().filter_by(id=perfil_id).one()
        self.all_action_categories = self.manager.action_category_manager.get_all()
        self.all_actions = self.manager.action_manager.get_all()
        self.all_perfil_actions = self.manager.perfil_action_manager.get_perfil_actions_by_perfil_id(perfil_id)
        self.action_and_categories_list = self.actions_and_categories_treeStore_setup()

    def actions_and_categories_treeStore_setup(self):
        selected_action_ids = [perfil_action.action_id for perfil_action in self.all_perfil_actions]
        lista = []
        for category in self.all_action_categories:
            lista_category = []
            lista_category.append(category.description)
            lista_category.append(category.id)
            for action in filter(lambda action: action.action_category_id == category.id, self.all_actions):
                lista_actions = []
                lista_actions.append(action.description)
                lista_actions.append(action.id in selected_action_ids)
                lista_actions.append(action.id)
                lista_category.append(lista_actions)
            lista.append(lista_category)
        return lista

    def should_parent_be_checked(self, i):
        j = 2
        while j < len(self.action_and_categories_list[i]):
            if self.action_and_categories_list[i][j][1] is False:
                return False
            j += 1
        return True

    def run(self):
        self.xml = get_gtk_builder('config_perfil')
        self.config_perfil = self.xml.get_object('perfil_admin')
        self.cancel_bnt = self.xml.get_object('cancel_bnt')
        self.xml.connect_signals(self)
        self.cancel_bnt = gtk.Button(stock=gtk.STOCK_CANCEL)
        self.cancel_bnt.connect("clicked", self.on_cancel_button_clicked)

        self.title = self.xml.get_object('label1')
        self.title.set_markup("<b>Configurar perfil: <big>%s</big></b>" % self.selected_perfil.perfil_description)

        books = self.action_and_categories_list

        self.store = gtk.TreeStore(str, bool, int)

        for i in range(len(books)):
            is_parent_checked = self.should_parent_be_checked(i)
            piter = self.store.append(None, [books[i][0], is_parent_checked, books[i][1]])
            j = 2
            while j < len(books[i]):
                self.store.append(piter, books[i][j])
                j += 1

        view = gtk.TreeView(self.store)

        renderer_books = gtk.CellRendererText()
        column_books = gtk.TreeViewColumn("Funcionalidades", renderer_books, text=0)
        view.append_column(column_books)

        renderer_in_out = gtk.CellRendererToggle()
        column_in_out = gtk.TreeViewColumn("Acesso", renderer_in_out, active=1)
        view.append_column(column_in_out)
        renderer_in_out.connect("toggled", self.on_toggled)

        scrollTree = gtk.ScrolledWindow()
        scrollTree.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
        scrollTree.add(view)

        self.xml.get_object('dialog-vbox3').add(scrollTree)
        self.config_perfil.show_all()

    def on_toggled(self, widget, path):
        current_value = self.store[path][1]
        self.store[path][1] = not current_value
        current_value = not current_value
        if len(path) == 1:
            piter = self.store.get_iter(path)
            citer = self.store.iter_children(piter)
            while citer is not None:
                self.store[citer][1] = current_value
                citer = self.store.iter_next(citer)
        elif len(path) != 1:
            citer = self.store.get_iter(path)
            piter = self.store.iter_parent(citer)
            citer = self.store.iter_children(piter)
            all_selected = True
            while citer is not None:
                if self.store[citer][1] is False:
                    all_selected = False
                    break
                citer = self.store.iter_next(citer)
            self.store[piter][1] = all_selected

    def on_apply_bnt_clicked(self, obj):
        lista_action_ids_selecionados = []
        parent_iter = self.store.get_iter_first()
        while parent_iter:
            children_iter = self.store.iter_children(parent_iter)
            while children_iter:
                coluna = self.store.get(children_iter, 0, 1, 2)
                if coluna[1]:
                    lista_action_ids_selecionados.append(coluna[2])
                children_iter = self.store.iter_next(children_iter)
            parent_iter = self.store.iter_next(parent_iter)
        self.manager.perfil_action_manager.delete_by_perfil_id(self.perfil_id)
        for action_id in lista_action_ids_selecionados:
            perfilAction = PerfilAction(action_id, self.perfil_id)
            self.manager.perfil_action_manager.insert(perfilAction)
        self.config_perfil.destroy()

    def on_cancel_button_clicked(self, obj):
        self.config_perfil.destroy()


class lista_perfil:

    def __init__(self, manager):

        self.manager = manager

        self.perfilList = self.manager.perfil_manager.get_all()
        self.cols = ['id','descrição do perfil']
        sequence = [str] * len(self.cols)
        self.perfilStore = gtk.TreeStore(* sequence)
        self.perfilView = gtk.TreeView(self.perfilStore)
        self.perfilView.connect('cursor-changed', self.get_selected_perfil)
        self.perfil_selecionado = None

    def run(self):

        self.xml = get_gtk_builder('lista_perfil')
        self.lista_perfil = self.xml.get_object('dialog1')
        self.xml.connect_signals(self)

        self.perfilView.cell = [None] * len(self.cols)
        tvcolumn = [None] * len(self.cols)
        for colnum, col in enumerate(self.cols):
            self.perfilView.cell[colnum] = gtk.CellRendererText()
        tvcolumn[colnum] = gtk.TreeViewColumn(col, self.perfilView.cell[colnum])
        tvcolumn[colnum].add_attribute(self.perfilView.cell[colnum], 'text', colnum)
        self.perfilView.append_column(tvcolumn[colnum])

        scrollTree = self.xml.get_object("scrollTree")
        scrollTree.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
        scrollTree.add(self.perfilView)

        for line in self.perfilList:
            self.perfilStore.append(None, [line.id, line.perfil_description])

        self.perfilView.show()
        scrollTree.show()
        self.lista_perfil.show()

    def get_selected_perfil(self, treeview):
        model, treeview_iter = treeview.get_selection().get_selected()
        row = self.perfilStore.get(treeview_iter, 0, 1)
        self.perfil_selecionado = Perfil(row[1])
        self.perfil_selecionado.id = row[0]

        field = self.xml.get_object('entry_desc')
        field.set_text(self.perfil_selecionado.perfil_description)
        title = self.xml.get_object('title_fields')
        title.set_markup("<b><big>Editar Perfil</big></b>")
        button = self.xml.get_object('button_persist')
        button.set_label('Editar')

    def on_edit_perfil_clicked(self, obj):
        if not self.perfil_selecionado:
            ok_only(_("<b>É necesssário selecionar um perfil para edita-lo.</b>\n\n"), Parent=None, ICON=gtk.MESSAGE_ERROR)

        tabela = self.xml.get_object('table_fields')
        title = self.xml.get_object('title_fields')
        field = self.xml.get_object('entry_desc')
        field.set_text(self.perfil_selecionado.perfil_description)
        title.set_markup("<b><big>Editar Perfil</big></b>")
        button = self.xml.get_object('button_persist')
        button.set_label('Editar')
        tabela.show()

    def on_perfil_novo_clicked(self, obj):
        self.perfil_selecionado = Perfil("")
        tabela = self.xml.get_object('table_fields')
        title = self.xml.get_object('title_fields')
        field = self.xml.get_object('entry_desc')
        field.set_text(self.perfil_selecionado.perfil_description)
        title.set_markup("<b><big>Salvar Perfil</big></b>")
        button = self.xml.get_object('button_persist')
        button.set_label('Salvar')
        tabela.show()

    def on_button_cancel_clicked(self, obj):
        self.xml.get_object('table_fields').hide()

    def on_button_persist_clicked(self, obj):
        field = self.xml.get_object('entry_desc')
        last_id = self.perfilList[-1:][0].id
        self.perfil_selecionado.perfil_description = field.get_text()
        if self.perfil_selecionado.id:
            self.manager.perfil_manager.update_perfil_desc(self.perfil_selecionado.id, self.perfil_selecionado.perfil_description)
        else:
            self.perfil_selecionado.id = last_id + 1
            self.manager.perfil_manager.insert(self.perfil_selecionado)

        self.perfilList = self.manager.perfil_manager.get_all()
        self.perfilStore.clear()
        for line in self.perfilList:
            self.perfilStore.append(None, [line.id, line.perfil_description])

        field.set_text("")
        self.perfil_selecionado = Perfil("")

    def on_delete_perfil_clicked(self, obj):
        tem_certeza = yes_no("Você realmente deseja deletar o perfil: %s" % self.perfil_selecionado.perfil_description, Parent=None)
        if tem_certeza.response:
            self.manager.perfil_manager.delete_by_id(self.perfil_selecionado.id)

        self.perfilList = self.manager.perfil_manager.get_all()
        self.perfilStore.clear()
        for line in self.perfilList:
            self.perfilStore.append(None, [line.id, line.perfil_description])

        self.xml.get_object('table_fields').hide()
        self.perfil_selecionado = Perfil("")

    def on_config_perfil_clicked(self, obj):
        if not self.perfil_selecionado:
            ok_only(_("<b>É necesssário selecionar um perfil para edita-lo.</b>\n\n"), Parent=None, ICON=gtk.MESSAGE_ERROR)
        else:
            config_perfil(manager = self.manager, perfil_id=self.perfil_selecionado.id).run()

    def on_cancel_bnt_clicked(self, obj):
        self.lista_perfil.destroy()



class consulta_movimento:

    def __init__(self, manager):

	self.cash_flow_manager = manager.cash_flow_manager
        self.open_debts_machine_manager = manager.open_debts_machine_manager
        self.open_debts_other_manager = manager.open_debts_other_manager

	self.cash_not_realized = self.open_debts_machine_manager.get_all()
        self.cols = ['Movimento Realizado','Movimento não Realizado']
        sequence = [str] * len(self.cols)
        self.cashFlowStore = gtk.TreeStore(* sequence)
        self.cashFlowView = gtk.TreeView(self.cashFlowStore)

        self.date_daily_calendar = DateEdit.DateEdit()
	self.date_daily_calendar_fim = DateEdit.DateEdit()


    def run(self):

        self.xml = get_gtk_builder('consulta_movimento')
        self.consulta_movimento = self.xml.get_object('window2')
        self.xml.connect_signals(self)

        self.xml.get_object("hbox_ini").pack_start(self.date_daily_calendar)
        self.date_daily_calendar.show()
	self.daily_calendar = self.date_daily_calendar.get_internal_calendar()

        self.xml.get_object("hbox_fim").pack_start(self.date_daily_calendar_fim)
        self.date_daily_calendar_fim.show()
	self.daily_calendar_fim = self.date_daily_calendar_fim.get_internal_calendar()

        self.daily_calendar.connect("day-selected",
                                    self.on_cash_flow_calendar_day_selected)

        self.daily_calendar_fim.connect("day-selected",
                                    self.on_cash_flow_calendar_day_selected)

        self.cashFlowView.cell = [None] * len(self.cols)
        tvcolumn = [None] * len(self.cols)

        for colnum, col in enumerate(self.cols):
            self.cashFlowView.cell[colnum] = gtk.CellRendererText()
	    tvcolumn[colnum] = gtk.TreeViewColumn(col, self.cashFlowView.cell[colnum])
            tvcolumn[colnum].add_attribute(self.cashFlowView.cell[colnum], 'text', colnum)
            self.cashFlowView.append_column(tvcolumn[colnum])

	scrollTree = self.xml.get_object("scrolledwindow")
        scrollTree.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
        scrollTree.add(self.cashFlowView)

	valor = 0
        for line in self.cash_flow_manager.get_all():
	    valor = valor + line.value

	debs_others = 0
        for item in self.open_debts_other_manager.get_all():
	    debs_others = debs_others + item.value
	
	for item in self.cash_not_realized:
	    print item.value
	    debs_others = debs_others + item.value

        self.cashFlowStore.append(None, [valor, debs_others])

        self.cashFlowView.show()
        self.consulta_movimento.show()

    def on_cash_flow_calendar_day_selected(self, obj):
        year, month, day = obj.get_date()
        month += 1 #Change range(0, 11) to range(1, 12)

	print str(day) + '-' + str(mohth) + '-' + str(year)
###BSI


class add_reserva:

    faults = ['comment']
    users_iters = {}
    reserve = None
    user = None
    borrowed_date = None

    data = {}
    data['comment'] = ""
    data['id_user'] = 0

    def __init__(self, manager, Parent=None):

        self.manager = manager
        self.list_bens_manager = self.manager.list_bens_manager
        self.users_manager = self.manager.users_manager
        self.reserve_manager = self.manager.reserve_manager


        self.xml = get_gtk_builder('add_reserva')
        self.add_reserva = self.xml.get_object('add_reserva')

        self.apply_bnt = self.xml.get_object('apply_bnt')
        self.comment = self.xml.get_object('comment')
        self.comment_buffer = self.comment.get_buffer()
        self.cancel_bnt = self.xml.get_object('cancel_bnt')

        self.UsuarioListStore = gtk.ListStore(gobject.TYPE_INT,
                                               gobject.TYPE_STRING)

        self.UsuarioComboBox = gtk.ComboBox(model=self.UsuarioListStore)

        cell = gtk.CellRendererText()
        self.UsuarioComboBox.pack_start(cell, True)
        self.UsuarioComboBox.add_attribute(cell, 'text', 1)
        self.UsuarioComboBox.set_row_separator_func(self.row_separator_func)

        table = self.xml.get_object("table1")
        table.attach(child=self.UsuarioComboBox,
                     left_attach=1,
                     right_attach=2,
                     top_attach=1,
                     bottom_attach=2,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("label3").set_mnemonic_widget(self.UsuarioComboBox)
        self.UsuarioComboBox.show()


        if self.manager:
            for i in self.users_manager.get_all():
                iter = self.UsuarioListStore.append((int(i.id), i.nick))
                self.users_iters[i.id] = iter

        self.xml.connect_signals(self)

        self.cancel_bnt = gtk.Button(stock=gtk.STOCK_CANCEL)
        self.cancel_bnt.connect("clicked", self.on_cancel_button_clicked)

        self.apply_bnt = gtk.Button(stock=gtk.STOCK_SAVE)
        self.apply_bnt.set_sensitive(False)
        self.apply_bnt.connect("clicked", self.on_apply_bnt_clicked)
        self.apply_bnt.set_no_show_all(True)

        if Parent:
            self.add_reserva.set_transient_for(Parent)

    def row_separator_func(self, model, iter):

        if model.get_value(iter, 0) == -1:
            return True
        else:
            return False


    def get_data(self):

        newdata = {}
        bf = self.comment_buffer
        newdata['comment'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())

        iter = self.UsuarioComboBox.get_active_iter()
        if iter:
            newdata['id_user'] = self.UsuarioListStore.get_value(iter, 0)
        else:
            ok_only(_("<b><big>É necesssário escolher o usuario.</big></b>\n\n"
                              "Caso nao tenha nenhum usuario cadastrado, realize o cadastro antes de reservar."),
                            Parent=None, ICON=gtk.MESSAGE_ERROR)

            return

        return newdata

    def get_new_data(self):

        new = self.get_data()

        def f(x):
            return x[1] != self.data[x[0]]

        return dict(filter(f, zip(new.keys(), new.values())))


    def on_cancel_button_clicked(self, obj):
        self.add_reserva.destroy()

    def on_apply_bnt_clicked(self, obj):
        data = self.get_new_data()

        if data:

            reserve = ReserveOfBorrow()

            for key, value in data.items():
                reserve.__setattr__(key, value)

            reserve_id = self.reserve_manager.get_user_id(reserve.id_user, self.heritage.id)

            if reserve_id:
                ok_only(_("<b><big>Nao foi possivel realizar reserva</big></b>\n\n"
                              "Este material ja possui reserva para este usuario."),
                            Parent=None, ICON=gtk.MESSAGE_ERROR)

                return

            else:

                reserve.reserve_date = datetime.datetime.now()
                reserve.id_heritage = self.heritage.id

                self.reserve_manager.insert(reserve)

                reserve_id = self.reserve_manager.get_all().filter_by(reserve_date=reserve.reserve_date).one()

                if reserve_id:
                     self.heritage.reserve_id = reserve_id.id

                     self.list_bens_manager.update(self.heritage)

                self.add_reserva.destroy()


    def run(self, heritage):

        self.heritage = heritage

        self.add_reserva.show()


class add_alienar_bem:

    faults = ['comment']
    reason_iters = {}
    reserve = None
    user = None
    borrowed_date = None

    data = {}
    data['comment'] = ""
    data['id_reason'] = 0

    def __init__(self, manager, Parent=None):

        self.manager = manager
        self.list_bens_manager = self.manager.list_bens_manager
        self.users_manager = self.manager.users_manager
        self.machines_alien_manager = self.manager.machines_alien_manager

        self.xml = get_gtk_builder('add_alienar_bem')
        self.add_alienar_bem = self.xml.get_object('add_alienar_bem')

        self.apply_bnt = self.xml.get_object('apply_bnt')
        self.comment = self.xml.get_object('comment')
        self.comment_buffer = self.comment.get_buffer()
        self.cancel_bnt = self.xml.get_object('cancel_bnt')


        self.ReasonListStore = gtk.ListStore(gobject.TYPE_INT,
                                               gobject.TYPE_STRING)

        self.ReasonComboBox = gtk.ComboBox(model=self.ReasonListStore)

        cell = gtk.CellRendererText()
        self.ReasonComboBox.pack_start(cell, True)
        self.ReasonComboBox.add_attribute(cell, 'text', 1)
        self.ReasonComboBox.set_row_separator_func(self.row_separator_func)

        table = self.xml.get_object("table1")
        table.attach(child=self.ReasonComboBox,
                     left_attach=1,
                     right_attach=2,
                     top_attach=1,
                     bottom_attach=2,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("label3").set_mnemonic_widget(self.ReasonComboBox)
        self.ReasonComboBox.show()

        if self.manager:
            for i in self.manager.reason_manager.get_all():
                iter = self.ReasonListStore.append((i.id, i.description))
                self.reason_iters[i.id] = iter

        self.xml.connect_signals(self)

        self.cancel_bnt = gtk.Button(stock=gtk.STOCK_CANCEL)
        self.cancel_bnt.connect("clicked", self.on_cancel_button_clicked)

        self.apply_bnt = gtk.Button(stock=gtk.STOCK_SAVE)
        self.apply_bnt.set_sensitive(False)
        self.apply_bnt.connect("clicked", self.on_apply_bnt_clicked)
        self.apply_bnt.set_no_show_all(True)

        if Parent:
            self.add_alienar_bem.set_transient_for(Parent)

    def row_separator_func(self, model, iter):

        if model.get_value(iter, 0) == -1:
            return True
        else:
            return False


    def get_data(self):

        newdata = {}
        bf = self.comment_buffer
        newdata['comment'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())

        iter = self.ReasonComboBox.get_active_iter()
        newdata['id_reason'] = self.ReasonListStore.get_value(iter, 0)

        return newdata

    def get_new_data(self):

        new = self.get_data()

        def f(x):
            return x[1] != self.data[x[0]]

        return dict(filter(f, zip(new.keys(), new.values())))


    def on_cancel_button_clicked(self, obj):
        self.add_alienar_bem.destroy()

    def on_apply_bnt_clicked(self, obj):
        data = self.get_new_data()

        if data:

            alienat = AlienationMachine()

            for key, value in data.items():
                alienat.__setattr__(key, value)

            alienat.date_alienation = datetime.datetime.now()
            alienat.heritage_id = self.heritage.id

            self.machines_alien_manager.insert(alienat)

            alienat_id = self.machines_alien_manager.get_all().filter_by(date_alienation=alienat.date_alienation).one()

            if alienat_id:
               self.heritage.alienat_id = alienat_id.id

               self.list_bens_manager.update(self.heritage)

        self.add_alienar_bem.destroy()

    def run(self, heritage):

        self.heritage = heritage

        self.add_alienar_bem.show()


class add_alienar_maquina:

    faults = ['comment']
    reason_iters = {}
    user = None

    data = {}
    data['comment'] = ""
    data['id_reason'] = 0

    def __init__(self, manager, Parent=None):

        self.manager = manager
        self.machine_manager = self.manager.machine_manager
        self.machines_alien_manager = self.manager.machines_alien_manager

        self.xml = get_gtk_builder('add_alienar_maquina')
        self.add_alienar_maquina = self.xml.get_object('add_alienar_maquina')

        self.apply_bnt = self.xml.get_object('apply_bnt')
        self.comment = self.xml.get_object('comment')
        self.comment_buffer = self.comment.get_buffer()
        self.cancel_bnt = self.xml.get_object('cancel_bnt')


        self.ReasonListStore = gtk.ListStore(gobject.TYPE_INT,
                                               gobject.TYPE_STRING)

        self.ReasonComboBox = gtk.ComboBox(model=self.ReasonListStore)

        cell = gtk.CellRendererText()
        self.ReasonComboBox.pack_start(cell, True)
        self.ReasonComboBox.add_attribute(cell, 'text', 1)
        self.ReasonComboBox.set_row_separator_func(self.row_separator_func)

        table = self.xml.get_object("table1")
        table.attach(child=self.ReasonComboBox,
                     left_attach=1,
                     right_attach=2,
                     top_attach=1,
                     bottom_attach=2,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("label3").set_mnemonic_widget(self.ReasonComboBox)
        self.ReasonComboBox.show()

        if self.manager:
            for i in self.manager.reason_manager.get_all():
                iter = self.ReasonListStore.append((i.id, i.description))
                self.reason_iters[i.id] = iter

        self.xml.connect_signals(self)

        self.cancel_bnt = gtk.Button(stock=gtk.STOCK_CANCEL)
        self.cancel_bnt.connect("clicked", self.on_cancel_button_clicked)

        self.apply_bnt = gtk.Button(stock=gtk.STOCK_SAVE)
        self.apply_bnt.set_sensitive(False)
        self.apply_bnt.connect("clicked", self.on_apply_bnt_clicked)
        self.apply_bnt.set_no_show_all(True)

        if Parent:
            self.add_alienar_maquina.set_transient_for(Parent)

    def row_separator_func(self, model, iter):

        if model.get_value(iter, 0) == -1:
            return True
        else:
            return False


    def get_data(self):

        newdata = {}
        bf = self.comment_buffer
        newdata['comment'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())

        iter = self.ReasonComboBox.get_active_iter()
        newdata['id_reason'] = self.ReasonListStore.get_value(iter, 0)

        return newdata

    def get_new_data(self):

        new = self.get_data()

        def f(x):
            return x[1] != self.data[x[0]]

        return dict(filter(f, zip(new.keys(), new.values())))


    def on_cancel_button_clicked(self, obj):
        self.add_alienar_maquina.destroy()

    def on_apply_bnt_clicked(self, obj):
        data = self.get_new_data()

        if data:

            alienat = AlienationMachine()

            for key, value in data.items():
                alienat.__setattr__(key, value)


            if self.maquina.alienat_id:
                ok_only(_("<b><big>Nao foi possivel realizar a alienacao.</big></b>\n\n"
                              "Este maquina ja esta alienada."),
                            Parent=None, ICON=gtk.MESSAGE_ERROR)

                self.add_alienar_maquina.destroy()

            else:
                alienat.date_alienation = datetime.datetime.now()

                self.machines_alien_manager.insert(alienat)

                alienat_id = self.machines_alien_manager.get_id(alienat.date_alienation)

                if alienat_id:
                    self.maquina.alienat_id = alienat_id

                    self.machine_manager.update(self.maquina)

                self.add_alienar_maquina.destroy()

    def run(self, maquina):

        self.maquina = maquina

        self.add_alienar_maquina.show()


class add_heritage:

    faults = ['number_ben']
    input = {}

    data = {}
    data['description'] = ""

    def __init__(self, manager, Parent=None):

        self.manager = manager
        self.list_bens_manager = self.manager.list_bens_manager

        self.xml = get_gtk_builder('add_heritage')
        self.add_heritage = self.xml.get_object('add_heritage')

        self.apply_bnt = self.xml.get_object('apply_bnt')
        self.description = self.xml.get_object('description')
        self.description_buffer = self.description.get_buffer()
        self.cancel_bnt = self.xml.get_object('cancel_bnt')

        self.reg_entry("name")
        self.reg_entry("number_ben")
        self.reg_entry("value")
        self.reg_entry("model")
        self.reg_entry("brand")

        self.xml.connect_signals(self)

        self.cancel_bnt = gtk.Button(stock=gtk.STOCK_CANCEL)
        self.cancel_bnt.connect("clicked", self.on_cancel_button_clicked)

        self.apply_bnt = gtk.Button(stock=gtk.STOCK_SAVE)
        self.apply_bnt.set_sensitive(False)
        self.apply_bnt.connect("clicked", self.on_apply_bnt_clicked)
        self.apply_bnt.set_no_show_all(True)

        if Parent:
            self.add_heritage.set_transient_for(Parent)

    def row_separator_func(self, model, iter):

        if model.get_value(iter, 0) == -1:
            return True
        else:
            return False

    def reg_entry(self, name):

        widget = self.xml.get_object(name)
        self.data[name] = ""
        self.input[name] = widget

        return widget


    def get_data(self):

        newdata = {}
        bf = self.description_buffer
        newdata['description'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())

        for key in self.input.keys():
            newdata[key] = self.input[key].get_text()

        return newdata

    def get_new_data(self):

        new = self.get_data()

        def f(x):
            return x[1] != self.data[x[0]]

        return dict(filter(f, zip(new.keys(), new.values())))


    def on_cancel_button_clicked(self, obj):
        self.add_heritage.destroy()

    def on_apply_bnt_clicked(self, obj):
        data = self.get_new_data()

        if data:

            heritage = Heritage()

            for key, value in data.items():
                heritage.__setattr__(key, value)

            self.list_bens_manager.insert(heritage)

        self.add_heritage.destroy()

    def run(self):

        self.add_heritage.show()


class add_heritage_machine:

    faults = ['number_ben']
    input = {}

    data = {}
    data['description'] = ""

    def __init__(self, manager, Parent=None):

        self.manager = manager
        self.list_bens_manager = self.manager.list_bens_manager

        self.xml = get_gtk_builder('add_heritage_machine')
        self.add_heritage_machine = self.xml.get_object('add_heritage_machine')

        self.apply_bnt = self.xml.get_object('apply_bnt')
        self.description = self.xml.get_object('description')
        self.description_buffer = self.description.get_buffer()
        self.cancel_bnt = self.xml.get_object('cancel_bnt')

        self.reg_entry("name")
        self.reg_entry("number_ben")
        self.reg_entry("model")
        self.reg_entry("brand")

        self.xml.connect_signals(self)

        self.cancel_bnt = gtk.Button(stock=gtk.STOCK_CANCEL)
        self.cancel_bnt.connect("clicked", self.on_cancel_button_clicked)

        self.apply_bnt = gtk.Button(stock=gtk.STOCK_SAVE)
        self.apply_bnt.set_sensitive(False)
        self.apply_bnt.connect("clicked", self.on_apply_bnt_clicked)
        self.apply_bnt.set_no_show_all(True)

	

        if Parent:
            self.add_heritage_machine.set_transient_for(Parent)

    def row_separator_func(self, model, iter):

        if model.get_value(iter, 0) == -1:
            return True
        else:
            return False

    def reg_entry(self, name):

        widget = self.xml.get_object(name)
        self.data[name] = ""
        self.input[name] = widget

        return widget


    def get_data(self):

        newdata = {}
        bf = self.description_buffer
        newdata['description'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())

        for key in self.input.keys():
            newdata[key] = self.input[key].get_text()

        return newdata

    def get_new_data(self):

        new = self.get_data()

        def f(x):
            return x[1] != self.data[x[0]]

        return dict(filter(f, zip(new.keys(), new.values())))


    def on_cancel_button_clicked(self, obj):
        self.add_heritage_machine.destroy()

    def on_apply_bnt_clicked(self, obj):
        data = self.get_new_data()

        if data:

            heritage = Heritage()

            for key, value in data.items():
                heritage.__setattr__(key, value)

	    heritage.value = 0
	    heritage.machine_id = self.machine_id

            self.list_bens_manager.insert(heritage)

        self.add_heritage_machine.destroy()

    def run(self, machine_id):

	self.machine_id = machine_id

        self.add_heritage_machine.show()

class block_user:

    faults = ['detalhes']
    description_iters = {}
    block_user = None
    user = None

    data = {}
    data['long_description'] = ""
    data['id_description_block'] = 0


    def __init__(self, manager, Parent=None):


        self.manager = manager
        self.block_manager = self.manager.users_block_manager
        self.users_manager = self.manager.users_manager


        self.xml = get_gtk_builder('block_user')
        self.block_user = self.xml.get_object('block_user')

        self.apply_bnt = self.xml.get_object('apply_bnt')
        self.detalhes = self.xml.get_object('long_description')
        self.detalhes_buffer = self.detalhes.get_buffer()
        self.cancel_bnt = self.xml.get_object('cancel_bnt')

        self.DescriptionListStore = gtk.ListStore(gobject.TYPE_INT,
                                               gobject.TYPE_STRING)

        self.DescriptionComboBox = gtk.ComboBox(model=self.DescriptionListStore)

        cell = gtk.CellRendererText()
        self.DescriptionComboBox.pack_start(cell, True)
        self.DescriptionComboBox.add_attribute(cell, 'text', 1)
        self.DescriptionComboBox.set_row_separator_func(self.row_separator_func)

        table = self.xml.get_object("table")
        table.attach(child=self.DescriptionComboBox,
                     left_attach=1,
                     right_attach=2,
                     top_attach=1,
                     bottom_attach=2,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("label4").set_mnemonic_widget(self.DescriptionComboBox)
        self.DescriptionComboBox.show()


        if self.manager:
            for i in self.manager.description_block_manager.get_all():
                iter = self.DescriptionListStore.append((i.id, i.description))
                self.description_iters[i.id] = iter

        self.xml.connect_signals(self)

        self.cancel_bnt = gtk.Button(stock=gtk.STOCK_CANCEL)
        self.cancel_bnt.connect("clicked", self.on_cancel_button_clicked)

        self.apply_bnt = gtk.Button(stock=gtk.STOCK_SAVE)
        self.apply_bnt.set_sensitive(False)
        self.apply_bnt.connect("clicked", self.on_apply_bnt_clicked)
        self.apply_bnt.set_no_show_all(True)

        if Parent:
            self.block_user.set_transient_for(Parent)

    def row_separator_func(self, model, iter):

        if model.get_value(iter, 0) == -1:
            return True
        else:
            return False


    def get_data(self):

        newdata = {}
        bf = self.detalhes_buffer
        newdata['long_description'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())

        iter = self.DescriptionComboBox.get_active_iter()
        newdata['id_description_block'] = self.DescriptionListStore.get_value(iter, 0)


        return newdata

    def get_new_data(self):

        new = self.get_data()

        def f(x):
            return x[1] != self.data[x[0]]

        return dict(filter(f, zip(new.keys(), new.values())))


    def on_cancel_button_clicked(self, obj):
        self.block_user.destroy()

    def on_apply_bnt_clicked(self, obj):
        data = self.get_new_data()

        if data:

            block = Block()

            for key, value in data.items():
                block.__setattr__(key, value)

            block.date_block = datetime.datetime.now()
            block.user = self.user.id

	    self.user.active = False

	    self.users_manager.update(self.user)

            self.block_manager.insert(block)

            os.system("passwd -l " + self.user.nick)

        self.block_user.destroy()

    def run(self, user):

        self.user = user

        self.block_user.show()


class block_borrow_user:

    faults = ['detalhes']
    description_iters = {}
    block_borrow_user = None
    user = None
    data = {}
    data['long_description'] = ""
    data['id_description_block_borrow'] = 0


    def __init__(self, manager, Parent=None):

        self.manager = manager
        self.block_borrow_manager = self.manager.users_block_borrow_manager
        self.users_manager = self.manager.users_manager

        self.xml = get_gtk_builder('block_user_schedule')
        self.block_user_schedule = self.xml.get_object('block_user_schedule')

        self.apply_bnt = self.xml.get_object('apply_bnt')
        self.detalhes = self.xml.get_object('long_description')
        self.detalhes_buffer = self.detalhes.get_buffer()
        self.cancel_bnt = self.xml.get_object('cancel_bnt')

        self.DescriptionBorrowListStore = gtk.ListStore(gobject.TYPE_INT,
                                               gobject.TYPE_STRING)

        self.DescriptionBorrowComboBox = gtk.ComboBox(model=self.DescriptionBorrowListStore)

        cell = gtk.CellRendererText()
        self.DescriptionBorrowComboBox.pack_start(cell, True)
        self.DescriptionBorrowComboBox.add_attribute(cell, 'text', 1)
        self.DescriptionBorrowComboBox.set_row_separator_func(self.row_separator_func)

        table = self.xml.get_object("table")
        table.attach(child=self.DescriptionBorrowComboBox,
                     left_attach=1,
                     right_attach=2,
                     top_attach=1,
                     bottom_attach=2,
                     xoptions=gtk.FILL,
                     yoptions=gtk.EXPAND|gtk.FILL)

        self.xml.get_object("label4").set_mnemonic_widget(self.DescriptionBorrowComboBox)
        self.DescriptionBorrowComboBox.show()


        if self.manager:
            for i in self.manager.description_block_borrow_manager.get_all():
                iter = self.DescriptionBorrowListStore.append((i.id, i.description))
                self.description_iters[i.id] = iter

        self.xml.connect_signals(self)

        self.cancel_bnt = gtk.Button(stock=gtk.STOCK_CANCEL)
        self.cancel_bnt.connect("clicked", self.on_cancel_button_clicked)
        self.cancel_bnt.set_no_show_all(True)

        self.apply_bnt = gtk.Button(stock=gtk.STOCK_SAVE)
        self.apply_bnt.set_sensitive(False)
        self.apply_bnt.connect("clicked", self.on_apply_bnt_clicked)
        self.apply_bnt.set_no_show_all(True)


        if Parent:
            self.block_user_schedule.set_transient_for(Parent)

    def row_separator_func(self, model, iter):

        if model.get_value(iter, 0) == -1:
            return True
        else:
            return False


    def get_data(self):

        newdata = {}
        bf = self.detalhes_buffer
        newdata['long_description'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())

        iter = self.DescriptionBorrowComboBox.get_active_iter()
        newdata['id_description_block_borrow'] = self.DescriptionBorrowListStore.get_value(iter, 0)


        return newdata

    def get_new_data(self):

        new = self.get_data()

        def f(x):
            return x[1] != self.data[x[0]]

        return dict(filter(f, zip(new.keys(), new.values())))


    def on_cancel_button_clicked(self, obj):
        self.block_user_schedule.destroy()


    def on_apply_bnt_clicked(self, obj):
        data = self.get_new_data()

        if data:

            blockBorrow = BlockBorrow()

            for key, value in data.items():
                 blockBorrow.__setattr__(key, value)

            blockBorrow.date_block = datetime.datetime.now()
            blockBorrow.user = self.user.id

            self.block_borrow_manager.insert(blockBorrow)


        self.block_user_schedule.destroy()

    def run(self, user):

        self.user = user

        self.block_user_schedule.show()


class adduser(user_edit):

    lock = False
    ui_file = 'add_user'

    def __init__(self, manager, price_per_hour, Parent=None):

        user_edit.__init__(self, manager, Parent)
        self.user_edit = user_edit
        self.cash_flow_manager = manager.cash_flow_manager
        self.price_per_hour = price_per_hour

        self.notebook = self.xml.get_object("notebook")
        self.faults = ['nick', 'full_name', 'email', 'password_entry_1',
            'password_entry_2']

        self.help_bnt = gtk.Button(stock=gtk.STOCK_HELP)
        self.buttonbox.pack_start(self.help_bnt)
        self.help_bnt.connect("clicked", self.on_help_button_clicked)
        self.buttonbox.set_child_secondary(self.help_bnt, True)

        self.cancel_bnt = gtk.Button(stock=gtk.STOCK_CANCEL)
        self.buttonbox.pack_start(self.cancel_bnt)
        self.cancel_bnt.connect("clicked", self.on_cancel_button_clicked)
        self.buttonbox.set_child_secondary(self.cancel_bnt, True)
        self.autorizoEnvio = self.xml.get_object("autorizoEnvio")

        self.back_button = gtk.Button(stock=gtk.STOCK_GO_BACK)
        self.buttonbox.pack_start(self.back_button)
        self.back_button.set_sensitive(False)
        self.back_button.connect("clicked", self.on_back_button_clicked)

        self.ok_bnt = gtk.Button(stock=gtk.STOCK_GO_FORWARD)
        self.buttonbox.pack_start(self.ok_bnt)
        self.ok_bnt.set_sensitive(False)
        self.ok_bnt.connect("clicked", self.on_ok_bnt_clicked)

        self.apply_bnt = gtk.Button(stock=gtk.STOCK_SAVE)
        self.buttonbox.pack_start(self.apply_bnt)
        self.apply_bnt.set_sensitive(False)
        self.apply_bnt.connect("clicked", self.on_apply_bnt_clicked)
        self.apply_bnt.set_no_show_all(True)

        #Credit table
        table = self.xml.get_object("credit_table")

        self.credit = gtk.SpinButton(climb_rate=0.01, digits=2)
        self.credit.set_increments(0.01, 1.00)
        self.credit.set_range(0, 1000)
        self.credit.connect("value-changed", self.credit_changed)
        self.xml.get_object("credit_label").set_mnemonic_widget(self.credit)

        table.attach(child=self.credit,
                     left_attach=1, right_attach=2,
                     top_attach=0, bottom_attach=1,
		     xoptions=gtk.FILL, yoptions=gtk.FILL)

        self.hour_entry = HourEntry.HourEntry()
        self.hour_entry.connect('time_changed', self.time_changed)
        table.attach(child=self.hour_entry,
                     left_attach=1, right_attach=2,
                     top_attach=1, bottom_attach=2,
		     xoptions=gtk.FILL, yoptions=gtk.FILL)
        self.xml.get_object("estimated_time").set_mnemonic_widget(self.hour_entry)

        self.buttonbox.show_all()
        table.show_all()

        self.xml.get_object('password_image').set_from_file(None)

    def on_nick_changed_done(self):
        nick = self.xml.get_object('nick').get_text()
        obj = self.xml.get_object('nick_status_image')
        nick_alert_hbox = self.xml.get_object('nick_alert_hbox')

        if nick != "" and MIN_NICK <= len(nick) <= MAX_NICK:
            if self.users_manager.get_all().filter_by(nick=nick).count() == 1:
                self.nick_found = True
                stock = gtk.STOCK_CANCEL
                nick_alert_hbox.show()
                self.on_back_button_clicked(None)
            else:
                self.nick_found = False
                stock = gtk.STOCK_APPLY
                nick_alert_hbox.hide()

            obj.set_from_stock(stock, gtk.ICON_SIZE_MENU)

        else:
            self.nick_found = False
            obj.set_from_file(None)

        self.check_forward_button()

    def on_cancel_button_clicked(self, obj):
        self.users.destroy()

    def on_help_button_clicked(self, obj):
        ok_only(_("<b><big>Informação para adicionar o usuário.</big></b>\n\n"
                              "Campos obrigatórios:\n\n   -Nome Completo;\n   -Login;\n   -Email;\n  -Senha.\n\n Formato para data: DD-MM-AAAA\n Formato para CEP:  xxxxx-xxx"),
                            Parent=None, ICON=gtk.MESSAGE_INFO)


    def on_back_button_clicked(self, obj):
        if self.notebook.get_current_page() == 1:
            self.notebook.set_current_page(0)
            self.back_button.set_sensitive(False)
            self.apply_bnt.hide()
            self.ok_bnt.show()

    def on_ok_bnt_clicked(self, obj):
        if self.notebook.get_current_page() == 0:
            self.notebook.set_current_page(1)
            self.back_button.set_sensitive(True)
            self.apply_bnt.show()
            self.ok_bnt.hide()



    def on_apply_bnt_clicked(self, obj):
        data = self.get_new_data()
        password = self.xml.get_object("password_entry_1").get_text()

        user = User(nick=data['nick'],
                    full_name=data['full_name'],
                    password=md5_cripto(password))

        address = Address()
        registro_geral = RegistroGeral()

        data.pop('nick')
        data.pop('full_name')

        for key, value in data.items():
            if key == "city" or key == "address" or key == "cep" or key == "bairro" or key == "state" or key == "pais":
                address.__setattr__(key, value)

	    elif key == "numero_ident" or key == "orgao_expeditor":
		registro_geral.__setattr__(key, value)	
	    elif key == "data_expedicao":
		registro_geral.date_expedicao = value
	    elif key == "staterg":
		registro_geral.state = value	

            else:
                user.__setattr__(key, value)

	user.autorizoEnvio = self.xml.get_object('autorizoEnvio').get_active()

        user.logado = False

        user.reg_date = datetime.datetime.now()

        #Credit!
        value = self.credit.get_value()

        if value:
            user.credit = value

        user.alterado = False

        self.users_manager.insert(user)

        user_id = self.users_manager.get_user_id(user.nick)

        #PERFIL
        index_perfil_selected = self.perfilComboBox.get_active()
        if(index_perfil_selected):
            perfil = self.perfilList[index_perfil_selected]
            perfil_user = Perfil_User(user_id, perfil.id)
            self.manager.perfil_user_manager.insert(perfil_user)

        address.user = user_id

        self.address_manager.insert(address)

        registro_geral.user = user_id

        self.manager.registro_geral_manager.insert(registro_geral)
	
        # Adicionar usuario no sistema
        os.system("adduser --disabled-password --quiet --add_extra_groups --gecos \"\" " + user.nick)
        os.system("echo \"" + user.nick+":"+password + "\" | chpasswd")
        os.system("chmod o-rwx /home/" + user.nick)

        #Avatar
        try:
            avatar_pixbuf = self.user_avatar_image.get_pixbuf()
        except ValueError:
            avatar_pixbuf = None

        if self.user_avatar and avatar_pixbuf:
            path = get_user_avatar_path(user.id)

            try:
                avatar_pixbuf.save(path, "png")
            except Exception, error:
                print error

        if value:
            #Insert Entry in Cash Flow
            lctime = localtime()
            current_hour = "%0.2d:%0.2d:%0.2d" % lctime[3:6]

            citem = CashFlowItem()
            citem.type = CASH_FLOW_TYPE_CREDIT_IN
            citem.value = value
            citem.user_id = user.id
            citem.year = lctime[0]
            citem.month = lctime[1]
            citem.day = lctime[2]
            citem.hour = current_hour

            self.cash_flow_manager.insert(citem)

        #Remove Callback
        if self.insert_connect_id:
            gobject.source_remove(self.insert_connect_id)
            self.insert_connect_id = 0

        self.users.destroy()

    def on_show_password_toggle_toggled(self, obj):
        status = obj.get_active()
        self.xml.get_object("password_entry_1").set_visibility(status)
        self.xml.get_object("password_entry_2").set_visibility(status)

    def on_password_entry_changed(self, obj):
        p1 = self.xml.get_object("password_entry_1").get_text()
        p2 = self.xml.get_object("password_entry_2").get_text()

        if p1 == p2 and p1 != "":
            stock = gtk.STOCK_APPLY
        elif p1 == p2 and p1 == "":
            stock = None
        else:
            stock = gtk.STOCK_CANCEL

	#self.ok_bnt.set_sensitive(p1==p2 and p1!="")
        self.apply_bnt.set_sensitive(p1==p2 and p1!="")
	
        if stock != None:
            self.xml.get_object("password_image").set_from_stock(stock,
                                                          gtk.ICON_SIZE_MENU)
        else:
            self.xml.get_object("password_image").set_from_file(None)

	
    def run(self):
        """
            Show dialog and return alterations
        """
        self.user_t = None
        self.users.show()
        self.connect()

    def credit_changed(self, obj):
        if not self.lock:
            self.lock = True
            tm = calculate_time(self.price_per_hour, obj.get_value())
            self.hour_entry.set_time(*tm)
            self.lock = False

    def time_changed(self, obj):
        if not self.lock:
            self.lock = True
            t = obj.get_time()
            self.credit.set_value(calculate_credit(self.price_per_hour, *t))
            self.lock = False


class change_password:
    def __init__(self, Parent=None):
        self.dialog = gtk.Dialog(_("Change password"), Parent,
                            gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT)

        self.dialog.set_border_width(6)
        self.dialog.set_has_separator(False)
        self.dialog.set_resizable(False)
        box = self.dialog.get_children()[0]
        box.set_spacing(12)

        self.cancel_bnt = self.dialog.add_button(gtk.STOCK_CANCEL,
                                                 gtk.RESPONSE_REJECT)

        self.change_bnt = self.dialog.add_button(_("C_hange password"),
                                                 gtk.RESPONSE_ACCEPT)

        self.change_bnt.set_sensitive(False)

        self.hbox = gtk.HBox()
        self.hbox.set_spacing(12)
        self.hbox.set_border_width(6)
        box.pack_start(self.hbox)

        icon = gtk.image_new_from_icon_name("gtk-dialog-authentication",
                                            gtk.ICON_SIZE_DIALOG)
        icon.set_alignment(0.50, 0)
        icon.set_padding(6, 0)
        self.hbox.pack_start(icon, expand=False)

        self.vbox = gtk.VBox()
        self.vbox.set_spacing(6)
        self.hbox.pack_start(self.vbox)

        title = gtk.Label()

        title.set_markup(_("<b><big>Mudar senha</big></b>\n\n"
                           "Para mudar a senha, entre com a nova "
                           "senha, repita-a para verificacao e "
                           "clique em <b>Mudar Senha</b>."))

        title.set_line_wrap(True)
        title.set_alignment(0, 0.50)
        self.vbox.pack_start(title, expand=False)

        self.table = gtk.Table()
        self.table.set_col_spacings(12)
        self.table.set_row_spacings(6)
        self.vbox.pack_start(self.table, expand=False, padding=6)

        self.password_1 = gtk.Entry()
        self.password_2 = gtk.Entry()

        self.password_1.set_visibility(False)
        self.password_2.set_visibility(False)

        self.password_1.connect("changed", self._pass_changed)
        self.password_2.connect("changed", self._pass_changed)

        self.table.attach(child=self.password_1,
                          left_attach=1, right_attach=2,
                          top_attach=1, bottom_attach=2)

        self.table.attach(child=self.password_2,
                          left_attach=1, right_attach=2,
                          top_attach=2, bottom_attach=3)

        label = gtk.Label(_("_New password:"))
        label.set_use_underline(True)
        label.set_alignment(0, 0.50)
        label.set_mnemonic_widget(self.password_1)
        self.table.attach(child=label,
                          left_attach=0, right_attach=1,
                          top_attach=1, bottom_attach=2,
                          xoptions=gtk.FILL, yoptions=gtk.FILL)

        label = gtk.Label(_("_Retype new password:"))
        label.set_use_underline(True)
        label.set_alignment(0, 0.50)
        label.set_mnemonic_widget(self.password_2)
        self.table.attach(child=label,
                          left_attach=0, right_attach=1,
                          top_attach=2, bottom_attach=3,
                          xoptions=gtk.FILL, yoptions=gtk.FILL)

        self.show_password = gtk.CheckButton(_("_Show password"))
        self.show_password.set_mode(False)
        self.show_password.connect("toggled", self._on_show_password_clicked)

        self.table.attach(child=self.show_password,
                          left_attach=1, right_attach=2,
                          top_attach=3, bottom_attach=4,
                          xoptions=gtk.FILL, yoptions=gtk.FILL)

    def _on_show_password_clicked(self, obj):
        status = obj.get_active()
        self.password_1.set_visibility(status)
        self.password_2.set_visibility(status)

    def _pass_changed(self, obj):
        pass_1 = self.password_1.get_text()
        pass_2 = self.password_2.get_text()

        self.change_bnt.set_sensitive(pass_1 == pass_2 and pass_1 != "")

    def run(self):
        self.hbox.show_all()
        r = self.dialog.run()
        password = self.password_1.get_text()
        self.dialog.destroy()

        if r != gtk.RESPONSE_REJECT:
            return password

class AddCredit:

    lock = False

    def __init__(self, price_per_hour, Parent=None):

        self.price_per_hour = price_per_hour

        self.xml = get_gtk_builder('add_credit')
        self.dialog = self.xml.get_object('add_credit')
        self.table = self.xml.get_object('table')
        self.credit = self.xml.get_object('credit')
        self.add_button = self.xml.get_object('add_button')
        self.textview_bf = self.xml.get_object('textview').get_buffer()

        self.hour_entry = HourEntry.HourEntry()
        self.hour_entry.show()
        self.hour_entry.connect('time_changed', self.time_changed)
        self.table.attach(child=self.hour_entry,
                          left_attach=1, right_attach=2,
                          top_attach=1, bottom_attach=2)

        self.xml.connect_signals(self)

    def show(self, all=True):
        if all:
            self.dialog.show_all()
        else:
            self.dialog.show()

    def run(self):
        resp = self.dialog.run()
        r = None
        notes = self.textview_bf.get_text(self.textview_bf.get_start_iter(),
                                          self.textview_bf.get_end_iter())

        if resp:
            r = self.credit.get_value()

        self.dialog.destroy()
        return r, notes

    def credit_changed(self, obj):
        if not self.lock:
            self.lock = True
            value = obj.get_value()
            self.add_button.set_sensitive(bool(value))
            tm = calculate_time(self.price_per_hour, value)
            self.hour_entry.set_time(*tm)
            self.lock = False

    def time_changed(self, obj):
        if not self.lock:
            self.lock = True
            t = obj.get_time()
            value = calculate_credit(self.price_per_hour, *t)
            self.add_button.set_sensitive(bool(value))
            self.credit.set_value(value)
            self.lock = False

class RemoveCredit:

    lock = False

    def __init__(self, users_manager, currency,
                 user_id, current_credit, Parent=None):

        self.users_manager = users_manager
        self.handler_id = self.users_manager.connect(
                        'credit_update', self.on_credit_update)

        self.currency = currency
        self.current_credit = current_credit
        self.user_id = user_id

        self.xml = get_gtk_builder('remove_credit')
        self.dialog = self.xml.get_object('remove_credit')
        self.current_credit_widget = self.xml.get_object('current_credit')
        self.credit = self.xml.get_object('credit')
        self.remove_button = self.xml.get_object('remove_button')
        self.textview_bf = self.xml.get_object('textview').get_buffer()

        self.credit.set_range(0, current_credit)

        self.current_credit_widget.set_label("%s %0.2f" % (currency,
                                                        self.current_credit))

        self.xml.connect_signals(self)

    def on_credit_update(self, obj, user_id, value):
        if self.user_id == user_id:
            self.current_credit = value
            self.credit.set_range(0, value)
            self.current_credit_widget.set_label("%s %0.2f" % (self.currency,
                                                        self.current_credit))

    def show(self, all=True):
        if all:
            self.dialog.show_all()
        else:
            self.dialog.show()

    def run(self):
        resp = self.dialog.run()
        r = None
        notes = self.textview_bf.get_text(self.textview_bf.get_start_iter(),
                                          self.textview_bf.get_end_iter())

        if resp:
            r = self.credit.get_value()

        self.users_manager.disconnect(self.handler_id)
        self.dialog.destroy()
        return r, notes

    def credit_changed(self, obj):
        self.remove_button.set_sensitive(bool(obj.get_value()))

class user_info:

    user_id = 0
    currency = ""

    def __init__(self, manager, Parent=None):

        xml = get_gtk_builder('userinfo')

        self.userinfo = xml.get_object('userinfo')
        self.registred = xml.get_object('registred')
        self.last_login = xml.get_object('last_login')
        self.login_count = xml.get_object('login_count')
        self.responsible = xml.get_object('responsible')
        self.user_avatar = xml.get_object('user_avatar')
        self.email = xml.get_object('email')
        self.nick = xml.get_object('nick')
        self.full_name = xml.get_object('full_name')
	
        xml.connect_signals(self)

        self.xml = xml
	self.xml.get_object('numero_ident').set_text("Não Informado")
	self.xml.get_object('orgao_expeditor').set_text("Não Informado")
	self.xml.get_object('date_expedicao').set_text("Não Informado")
	self.xml.get_object('staterg').set_text("Não Informado")
	self.xml.get_object('situation_occupation').set_text("Não Informado")

        self.manager = manager
        self.users_manager = self.manager.users_manager
        self.list_bens_manager = self.manager.list_bens_manager
        self.schedule_manager = self.manager.schedule_manager


        self.handler_id = self.users_manager.connect(
                        'credit_update', self.on_credit_update)

        if Parent:
            self.userinfo.set_transient_for(Parent)

    def montar_lista_emprestimo(self):

        self.treeview = self.xml.get_object("emprestimo_treeview")

        #TreeView
        self.model = gtk.ListStore(gobject.TYPE_STRING,
                              gobject.TYPE_STRING,
                              gobject.TYPE_STRING
                              )

        self.model.clear()

        #ID
        column = gtk.TreeViewColumn(_("Material"), gtk.CellRendererText(), text=0)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(0)
        column.set_resizable(True)
        column.set_expand(False)

        self.treeview.append_column(column)

            #Time
        column = gtk.TreeViewColumn(_("Data do emprestimo"), gtk.CellRendererText(), text=1)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(1)
        column.set_resizable(True)
        column.set_expand(False)

        self.treeview.append_column(column)

            #Time
        column = gtk.TreeViewColumn(_("Data da devolução"), gtk.CellRendererText(), text=2)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(2)
        column.set_resizable(True)
        column.set_expand(False)


        self.treeview.append_column(column)
        self.name_column = column

        #self.model = model
        self.model_filtered = self.model.filter_new()
        self.model_sortable = gtk.TreeModelSort(self.model_filtered)
        self.treeview.set_model(self.model_sortable)

        self.xml.connect_signals(self)


        for schedule in self.schedule_manager.get_all().filter_by(id_user=self.user_id).all():
            if schedule:
                  self.model.append((schedule.name_heritage, schedule.borrowed_date.strftime("%d/%m/%y"), schedule.return_date.strftime("%d/%m/%y")))

        self.treeview.set_sensitive(True)

    def montar_lista_processos(self):

        self.treeview = self.xml.get_object("processos_treeview")

        #TreeView
        self.model = gtk.ListStore(gobject.TYPE_STRING,
                              gobject.TYPE_STRING
                              )

        self.model.clear()

        #ID
        column = gtk.TreeViewColumn(_("PID"), gtk.CellRendererText(), text=0)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(0)
        column.set_resizable(True)
        column.set_expand(False)

        self.treeview.append_column(column)

            #Time
        column = gtk.TreeViewColumn(_("Processo"), gtk.CellRendererText(), text=1)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(1)
        column.set_resizable(True)
        column.set_expand(False)

        self.treeview.append_column(column)

        self.name_column = column

        #self.model = model
        self.model_filtered = self.model.filter_new()
        self.model_sortable = gtk.TreeModelSort(self.model_filtered)
        self.treeview.set_model(self.model_sortable)

        self.xml.connect_signals(self)

	try:
	   f_texto = open("/home/tux/.processos/."+self.full_name+"-processos.txt","r")

	   for processo in f_texto.readlines():
            var = ""
            var2 = ""

            var = string.strip(processo[0:5])
            var2 = string.strip(processo[6:])

            self.model.append((var, var2))

	except:	
   	    pass
	
	
        self.treeview.set_sensitive(True)


    def on_credit_update(self, obj, user_id, value):
        if self.user_id == user_id:
            valor = value

    def run(self, currency, user, credit, last_machine=None):

        self.user_id = user.id
        self.currency = currency
        self.nick = user.nick
	self.full_name = user.full_name

        string_vars = ('full_name', 'nick',
                       'responsible', 'login_count', 'phone')

        for name in string_vars:
            value = user.__getattribute__(name)

            if value != None:
                widget = self.xml.get_object(name)
                widget.set_text(str(value))

        self.userinfo.set_title(_('%s Properties') % user.full_name)

        address = self.manager.address_manager.get_all().filter_by(user=self.user_id).all()

        if address:
            address = address[0]

            if address.address:
               bf = self.xml.get_object('address').get_buffer()
               bf.set_text(address.address)
	
            if address.state:
               state = self.manager.state_manager.get_all().filter_by(id=address.state).one()
               self.xml.get_object('state').set_text(state.name)
            else:
               self.xml.get_object('state').set_text("Não Informado")

            if address.pais:
               pais = self.manager.pais_manager.get_all().filter_by(id=address.pais).one()
               self.xml.get_object('pais').set_text(pais.description)
            else:
               self.xml.get_object('pais').set_text("Não Informado")

            if address.city:
	       city = self.manager.city_manager.get_all().filter_by(id=address.city).one()
               self.xml.get_object('city').set_text(city.name)
	    else:
               self.xml.get_object('city').set_text("Não Informado")
	
            if address.cep:
               self.xml.get_object('cep').set_text(str(address.cep))
	    else:
               self.xml.get_object('cep').set_text("-")

        registro_geral = self.manager.registro_geral_manager.get_all().filter_by(user=self.user_id).all()

        if registro_geral:
            registro_geral = registro_geral[0]

            if registro_geral.numero_ident:
               self.xml.get_object('numero_ident').set_text(str(registro_geral.numero_ident))

	    if registro_geral.orgao_expeditor:
               self.xml.get_object('orgao_expeditor').set_text(str(registro_geral.orgao_expeditor))

	    if registro_geral.date_expedicao:
	       date_expedicao = map(int, registro_geral.date_expedicao.split('-'))

               self.xml.get_object('date_expedicao').set_text(datetime.date(*date_expedicao).strftime("%x"))

	    if registro_geral.state:
               state = self.manager.state_manager.get_all().filter_by(id=registro_geral.state).one()
               self.xml.get_object('staterg').set_text(state.sigla)

        if user.email:
            widget = self.xml.get_object('email')
            widget.set_uri("mailto:%s" % user.email)
            widget.set_label(user.email)
        else:
            self.xml.get_object('email').hide()

	if user.cpf:
	   cpf = CPF(user.cpf)
	   self.xml.get_object('cpf').set_text(cpf.__str__())
	else:
	   self.xml.get_object('cpf').set_text("Não Informado")

        if user.last_login:
            self.last_login.set_text(user.last_login.ctime())

        if last_machine:
            self.xml.get_object("last_machine").set_text(last_machine)

        if user.reg_date:
            self.registred.set_text(user.reg_date.ctime())


        if user.notes:
            bf = self.xml.get_object('notes').get_buffer()
            bf.set_text(user.notes)

        if user.curriculo:
            bf = self.xml.get_object('curriculo').get_buffer()
            bf.set_text(user.curriculo)

        if user.birth:
            birth = map(int, user.birth.split('-'))
            self.xml.get_object("birth").set_text(
                    datetime.date(*birth).strftime("%x")
                    )
	else:
	    self.xml.get_object("birth").set_text("Não Informado")

        #if user.credit != None:
        #    self.xml.get_object('credit').set_text(
        #            "%s %0.2f" % (currency, user.credit)
        #            )

        if user.sex == 0:
            self.xml.get_object('sex').set_text("Não Informado")
        elif user.sex == 1:
            self.xml.get_object('sex').set_text("Feminino")
        else:
            self.xml.get_object('sex').set_text("Masculino")

        if user.occupation:
            occupation = self.manager.occupation_manager.get_all().filter_by(id=user.occupation).one()
            self.xml.get_object('occupation').set_text(occupation.description)

            if user.situation_occupation:
                situation_occupation = self.manager.situation_occupation_manager.get_all().filter_by(id=user.situation_occupation).one()
                self.xml.get_object('situation_occupation').set_text(situation_occupation.description)

        else:
            self.xml.get_object('occupation').set_text("Não Informado")

        if user.etnia:
            etnia = self.manager.etnia_manager.get_all().filter_by(id=user.etnia).one()
            self.xml.get_object('etnia').set_text(etnia.description)
        else:
            self.xml.get_object('etnia').set_text("Não Informado")

        if user.marital_status:
            marital_status = self.manager.marital_status_manager.get_all().filter_by(id=user.marital_status).one()
            self.xml.get_object('marital_status').set_text(marital_status.description)
        else:
            self.xml.get_object('marital_status').set_text("Não Informado")

        if user.type_deficiency:
            type_deficiency = self.manager.type_deficiency_manager.get_all().filter_by(id=user.type_deficiency).one()
            self.xml.get_object('type_deficiency').set_text(type_deficiency.description)
        else:
            self.xml.get_object('type_deficiency').set_text("Não possui")

        if user.renda_familiar:
            renda_familiar = self.manager.renda_familiar_manager.get_all().filter_by(id=user.renda_familiar).one()
            self.xml.get_object('renda_familiar').set_text(renda_familiar.description)
        else:
            self.xml.get_object('renda_familiar').set_text("Não Informado")

        if user.schooling:
            schooling = self.manager.schooling_manager.get_all().filter_by(id=user.schooling).one()
            self.xml.get_object('schooling').set_text(schooling.description)
        else:
            self.xml.get_object('schooling').set_text("Não Informado")


        if user.active:
            self.xml.get_object('active').set_text(_("True"))
        else:
            self.xml.get_object('active').set_text(_("False"))

        self.montar_lista_emprestimo()
        self.montar_lista_processos()

        #Avatar
        if user_has_avatar(user.id):
            self.user_avatar.set_from_file(get_user_avatar_path(user.id))
        else:
            self.user_avatar.hide()

        self.userinfo.run()
        self.users_manager.disconnect(self.handler_id)
        self.userinfo.destroy()


class heritage_mach_info:

    user_id = 0
    currency = ""

    def __init__(self, manager, Parent=None):

        xml = get_gtk_builder('heritagemachinfo')

        self.heritagemachinfo = xml.get_object('heritagemachinfo')
        self.mac = xml.get_object('mac')
        self.ip = xml.get_object('ip')
        self.userL = xml.get_object('user')
        self.machdescription = xml.get_object('machdescription')
        self.description = xml.get_object('description')
        self.name = xml.get_object('name')
        self.number_ben = xml.get_object('number_ben')
        self.value = xml.get_object('value')
        self.model = xml.get_object('model')
        self.brand = xml.get_object('brand')

        xml.connect_signals(self)

        self.xml = xml
        self.list_bens_manager = manager.list_bens_manager
        self.users_manager = manager.users_manager
	self.machine_manager = manager.machine_manager

        if Parent:
            self.heritagemachinfo.set_transient_for(Parent)


    def run(self, heritage):


        string_vars = ('name', 'number_ben', 'value', 'model',
                       'brand')

        for name_vars in string_vars:
            value_vars = heritage.__getattribute__(name_vars)

            if value_vars != None:
                widget = self.xml.get_object(name_vars)
                widget.set_text(str(value_vars))

        self.heritagemachinfo.set_title(_('%s Properties') % heritage.name)

        if heritage.name:
            self.xml.get_object("name").set_text(heritage.name)

        if heritage.number_ben:
            self.xml.get_object("number_ben").set_text(heritage.number_ben)

        if heritage.model:
            self.xml.get_object("model").set_text(heritage.model)

        if heritage.description:
            bf = self.xml.get_object('description').get_buffer()
            bf.set_text(heritage.description)


        if heritage.brand:
            self.xml.get_object("brand").set_text(heritage.brand)

        if heritage.value != None:
            self.xml.get_object('value').set_text(
                    "R$ %s" % (heritage.value)
                    )

        if heritage.machine_id:
	    try:
		machine = self.machine_manager.get_all().filter_by(id=heritage.machine_id).one()

		self.xml.get_object('mac').set_text(machine.mac)
		self.xml.get_object('ip').set_text(machine.ip)
		if machine.description:
		   bf = self.xml.get_object('machdescription').get_buffer()
                   bf.set_text(machine.description)
	
                last_user = self.machine_manager.get_last_user_id(heritage.machine_id)
	        if last_user:
                   user_fullname = self.users_manager.get_full_name(last_user)
                   self.xml.get_object('user').set_text(user_fullname)
	        else:
	           self.xml.get_object('user').set_text(_("Nenhum usuário utilizou a máquina"))

            except:
		self.xml.get_object('mac').set_text(_("-"))
		self.xml.get_object('ip').set_text(_("-"))
		self.xml.get_object('user').set_text(_("-"))
		

        self.heritagemachinfo.run()
        self.heritagemachinfo.destroy()


class heritage_info:

    user_id = 0
    currency = ""

    def __init__(self, manager, Parent=None):

        xml = get_gtk_builder('heritageinfo')

        self.heritageinfo = xml.get_object('heritageinfo')
        self.borrowed = xml.get_object('borrow_id')
        self.description = xml.get_object('description')
        self.name = xml.get_object('name')
        self.number_ben = xml.get_object('number_ben')
        self.value = xml.get_object('value')
        self.model = xml.get_object('model')
        self.brand = xml.get_object('brand')
        self.treeview = xml.get_object('reserve_treeview')

        xml.connect_signals(self)

        self.xml = xml
        self.list_bens_manager = manager.list_bens_manager
        self.reserve_manager = manager.reserve_manager
        self.users_manager = manager.users_manager
        self.schedule_manager = manager.schedule_manager

        if Parent:
            self.heritageinfo.set_transient_for(Parent)

    def montar_lista_reserva(self):

        self.treeview = self.xml.get_object("reserve_treeview")

        #TreeView
        self.model = gtk.ListStore(gobject.TYPE_STRING,
                              gobject.TYPE_STRING
                              )

        self.model.clear()

        #ID
        column = gtk.TreeViewColumn(_("Usuario"), gtk.CellRendererText(), text=0)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(0)
        column.set_resizable(True)
        column.set_expand(False)

        self.treeview.append_column(column)

            #Time
        column = gtk.TreeViewColumn(_("Data da reserva"), gtk.CellRendererText(), text=1)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(1)
        column.set_resizable(True)
        column.set_expand(False)


        self.treeview.append_column(column)
        self.name_column = column

        #self.model = model
        self.model_filtered = self.model.filter_new()
        self.model_sortable = gtk.TreeModelSort(self.model_filtered)
        self.treeview.set_model(self.model_sortable)

        self.xml.connect_signals(self)


        for reserve in self.list_reserve:
            user_fullname = self.users_manager.get_full_name(reserve.id_user)

            if user_fullname:
                username = user_fullname
            else:
                username = _("Unknown user")

            self.model.append((username, reserve.reserve_date.strftime("%d/%m/%y %H:%M")))

        self.treeview.set_sensitive(True)


    def run(self, heritage):


        string_vars = ('name', 'number_ben', 'value', 'model',
                       'brand')

        for name_vars in string_vars:
            value_vars = heritage.__getattribute__(name_vars)

            if value_vars != None:
                widget = self.xml.get_object(name_vars)
                widget.set_text(str(value_vars))

        self.heritageinfo.set_title(_('%s Properties') % heritage.name)

        if heritage.name:
            self.xml.get_object("name").set_text(heritage.name)

        if heritage.number_ben:
            self.xml.get_object("number_ben").set_text(heritage.number_ben)

        if heritage.model:
            self.xml.get_object("model").set_text(heritage.model)

        if heritage.description:
            bf = self.xml.get_object('description').get_buffer()
            bf.set_text(heritage.description)

        if heritage.id:
            self.list_reserve = self.reserve_manager.get_reserve_id(heritage.id)
            self.montar_lista_reserva()

        if heritage.brand:
            self.xml.get_object("brand").set_text(heritage.brand)

        if heritage.value != None:
            self.xml.get_object('value').set_text(
                    "R$ %s" % (heritage.value)
                    )

        if heritage.borrow_id:
            schedule = self.schedule_manager.get_all().filter_by(id=heritage.borrow_id).one()
            if schedule:
                user_fullname = self.users_manager.get_full_name(schedule.id_user)
                self.xml.get_object('borrow_id').set_text(_("Para: %s") % user_fullname)

        else:
            self.xml.get_object('borrow_id').set_text(_("Disponivel"))

        self.heritageinfo.run()
        self.heritageinfo.destroy()


class reserveSchedule_info:

    user_id = 0
    currency = ""

    def __init__(self, manager, Parent=None):

        xml = get_gtk_builder('scheresinfo')

        self.scheresinfo = xml.get_object('scheresinfo')
        self.borrowed = xml.get_object('date_return')
        self.description = xml.get_object('comment')
        self.name = xml.get_object('name')
        self.number_ben = xml.get_object('number_ben')
        self.brand = xml.get_object('brand')
        self.treeviewReser = xml.get_object('reserve_treeview')
	self.treeviewReser.connect("row-activated", self.on_resre_activated)

        xml.connect_signals(self)

        self.xml = xml
        self.list_bens_manager = manager.list_bens_manager
        self.reserve_manager = manager.reserve_manager
        self.users_manager = manager.users_manager
        self.schedule_manager = manager.schedule_manager
	

        if Parent:
            self.scheresinfo.set_transient_for(Parent)


    def recriar_treeview(self):

	self.model.clear()

	self.list_reserve = self.reserve_manager.get_reserve_id(self.heritageN.id)

	for reserve in self.list_reserve:
	    user_fullname = self.users_manager.get_full_name(reserve.id_user)

	    if user_fullname:
	       username = user_fullname
	    else:
	       username = _("Unknown user")

	    self.model.append((reserve.id, username, reserve.reserve_date.strftime("%d/%m/%y %H:%M")))

	self.treeviewReser.set_model(self.model)


    def on_resre_activated(self, widget, row, col):
	
	model = widget.get_model()
        id = model[row][0]
        reserve = self.reserve_manager.get_all().filter_by(id=id).one()

	d = delete(_("<b><big>Tem certeza que deseja remover a "
                                 "reserva para este usuário?</big></b>\n\n"),
                               Parent=None)

        if d.response:
	    if reserve.id_user:
                   self.reserve_manager.delete_by_id(reserve.id)
		   self.heritageN.reserve_id = None

		   self.list_bens_manager.update(self.heritageN)

		   self.recriar_treeview()


    def montar_lista_reserva(self):

        #TreeView
        self.model = gtk.ListStore(gobject.TYPE_INT,
				   gobject.TYPE_STRING,
                                   gobject.TYPE_STRING
                                  )

        self.model.clear()

	#ID
        column = gtk.TreeViewColumn(_("Ordem"), gtk.CellRendererText(), text=0)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(0)
        column.set_resizable(True)
        column.set_expand(False)

        self.treeviewReser.append_column(column)

        #ID
        column = gtk.TreeViewColumn(_("Usuario"), gtk.CellRendererText(), text=1)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(1)
        column.set_resizable(True)
        column.set_expand(False)

        self.treeviewReser.append_column(column)

        #Time
        column = gtk.TreeViewColumn(_("Data da reserva"), gtk.CellRendererText(), text=2)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(2)
        column.set_resizable(True)
        column.set_expand(False)


        self.treeviewReser.append_column(column)
        self.name_column = column

        #self.model = model
        self.model_filtered = self.model.filter_new()
        self.model_sortable = gtk.TreeModelSort(self.model_filtered)
        self.treeviewReser.set_model(self.model_sortable)

        self.xml.connect_signals(self)


        for reserve in self.list_reserve:
            user_fullname = self.users_manager.get_full_name(reserve.id_user)

            if user_fullname:
                username = user_fullname
            else:
                username = _("Unknown user")

            self.model.append((reserve.id, username, reserve.reserve_date.strftime("%d/%m/%y %H:%M")))

        self.treeviewReser.set_sensitive(True)



    def run(self, heritage):

        self.scheresinfo.set_title(_('%s Properties') % heritage.name)

	self.heritageN = heritage

        if heritage.name:
            self.xml.get_object("name_heritage").set_text(heritage.name)


	if heritage.id:
            self.list_reserve = self.reserve_manager.get_reserve_id(heritage.id)
            self.montar_lista_reserva()

        if heritage.borrow_id:
            schedule = self.schedule_manager.get_all().filter_by(id=heritage.borrow_id).one()
            if schedule:
		if schedule.id_user:
                   full_name, email, phone = self.users_manager.get_full_name_email_phone(schedule.id_user)

		   if full_name:
                      self.xml.get_object('borrow_id').set_text(full_name)
		   if email:
		      self.xml.get_object('email').set_text(email)
		   else:
		      self.xml.get_object('email').set_text("Não informado")
		   if phone:
		      self.xml.get_object('phone').set_text(phone)
		   else:
		      self.xml.get_object('phone').set_text("Não informado")

		if schedule.responsible_user:
		   self.xml.get_object('responsible_user').set_text(schedule.responsible_user)
		else:
		   self.xml.get_object('responsible_user').set_text("Não informado")

		if schedule.comment:
		   bf = self.xml.get_object('comment').get_buffer()
                   bf.set_text(schedule.comment)

		if schedule.return_date:
		   self.xml.get_object('return_date').set_text(schedule.return_date.strftime("%d/%m/%y"))

        else:
            self.xml.get_object('borrow_id').set_text(_("Disponivel"))

        self.scheresinfo.run()
        self.scheresinfo.destroy()


class AlertAddMachine:
    response = None

    def __init__(self, Parent=None):

        self.xml = get_gtk_builder('add_machine')
        self.dialog = self.xml.get_object('alert_add_machine')
        self.dialog.set_title("")

        if Parent:
            self.dialog.set_transient_for(Parent)

    def run(self):
        r = False

        if self.dialog.run():
            r = True

        self.dialog.destroy()
        return r

class AddMachine:

    response = None
    faults = ['name', 'hash_id']
    accept_first_new = False
    insert_connect_id = 0
    category_iters = {}

    def __init__(self, Parent=None, Manager=None):

        self.manager = Manager

        self.insert_connect_id = self.manager.machine_category_manager.connect(
                                            'insert',
                                            self.on_insert_category_machine)

        self.xml = get_gtk_builder('add_machine')

        self.dialog = self.xml.get_object('add_machine')
        self.hash_id = self.xml.get_object('hash_id')
        self.okbnt = self.xml.get_object('okbnt')
        self.description = self.xml.get_object('description')
        self.description_buffer = self.description.get_buffer()
        self.name_entry = self.xml.get_object('name_entry')
        self.cancelbnt = self.xml.get_object('cancelbnt')

        self.CategoryListStore = gtk.ListStore(gobject.TYPE_INT,
                                               gobject.TYPE_STRING)

        #self.CategoryComboBox = gtk.ComboBox(model=self.CategoryListStore)

        #cell = gtk.CellRendererText()
        #self.CategoryComboBox.pack_start(cell, True)
        #self.CategoryComboBox.add_attribute(cell, 'text', 1)
        #self.CategoryComboBox.set_row_separator_func(self.row_separator_func)

        #table = self.xml.get_object("table")
        #table.attach(child=self.CategoryComboBox,
        #             left_attach=1,
        #             right_attach=2,
        #             top_attach=2,
        #             bottom_attach=3,
        #             xoptions=gtk.FILL,
        #             yoptions=gtk.EXPAND|gtk.FILL)

        #self.xml.get_object("category_label").set_mnemonic_widget(self.CategoryComboBox)
        #self.CategoryComboBox.show()

        #Populate categories
        #iter = self.CategoryListStore.append((0, _("None")))
        #self.category_iters[0] = iter
        #self.CategoryComboBox.set_active_iter(iter)

        #self.CategoryListStore.append((-1, ""))

        #if self.manager:
        #    for i in self.manager.machine_category_manager.get_all():
        #        iter = self.CategoryListStore.append((i.id, i.name))
        #        self.category_iters[i.id] = iter

        self.xml.connect_signals(self)

        self.name_entry.connect('changed', self.name_entry_changed)
        self.hash_id.connect('changed', self.hash_id_changed)

        if Parent:
            self.dialog.set_transient_for(Parent)

    def hash_id_changed(self, obj):
        if len(obj.get_text()) <= 100:
            if 'hash_id' in self.faults:
                self.faults.remove('hash_id')
        else:
            if not 'hash_id' in self.faults:
                self.faults.append('hash_id')

        self.okbnt.set_sensitive(not(bool(self.faults)))

    def name_entry_changed(self, obj):
        if bool(obj.get_text()):
            if 'name' in self.faults:
                self.faults.remove('name')
        else:
            if not 'name' in self.faults:
                self.faults.append('name')

        self.okbnt.set_sensitive(not(bool(self.faults)))

    def on_new_category_clicked(self, obj):
        if self.manager:
            self.accept_first_new = True
            self.manager.add_new_machine_category_clicked(None)
            self.accept_first_new = False

    def row_separator_func(self, model, iter):

        if model.get_value(iter, 0) == -1:
            return True
        else:
            return False

    def on_insert_category_machine(self, manager, category):
        iter = self.CategoryListStore.append((category.id, category.name))
        self.category_iters[category.id] = iter

        if self.accept_first_new:
            self.CategoryComboBox.set_active_iter(iter)

    def run(self, data=None, set_hash_sensitive=False):
        if data:
            if 'name' in data:
                if 'name' in self.faults:
                    self.faults.remove('name')

                self.name_entry.set_text(data['name'])

            if 'description' in data:
                self.description_buffer.set_text(data['description'])

            #if 'category_id' in data:
            #    if data['category_id'] in self.category_iters:
            #        iter = self.category_iters[data['category_id']]
            #        self.CategoryComboBox.set_active_iter(iter)

            if 'hash_id' in data:
                if 'hash_id' in self.faults:
                    self.faults.remove('hash_id')

                self.hash_id.set_text(data['hash_id'])

        self.hash_id.set_sensitive(set_hash_sensitive)

        if self.dialog.run():
            bf = self.description_buffer
            #iter = self.CategoryComboBox.get_active_iter()

            response = {'name': self.name_entry.get_text(),
                        'description': bf.get_text(bf.get_start_iter(),
                              bf.get_end_iter()),
                        'hash_id': self.hash_id.get_text()
                        }

            #if iter:
            #    response['category_id'] = self.CategoryListStore.get_value(iter, 0)

            if self.insert_connect_id:
                gobject.source_remove(self.insert_connect_id)

            self.dialog.destroy()
            return response

        if self.insert_connect_id:
            gobject.source_remove(self.insert_connect_id)

        self.dialog.destroy()

class block_machine:
    def __init__(self, machine_name, Parent=None):
        self.xml = get_gtk_builder('block_machine')
        self.dialog = self.xml.get_object("dialog")

        if Parent:
            self.dialog.set_transient_for(Parent)

        self.xml.get_object("action_combo").set_active(0)
        self.xml.get_object("title").set_markup(
               _("<b><big>Voce realmente deseja encerrar a sessão do usuário que está na máquina %s ?</big></b>") % machine_name)

        self.xml.connect_signals(self)

    def on_after_toggled(self, obj):
        self.xml.get_object("action_combo").set_sensitive(obj.get_active())

    def run(self):
        block = bool(self.dialog.run())
        after = self.xml.get_object("after").get_active()
        action = self.xml.get_object("action_combo").get_active()
        self.dialog.destroy()
        return block, after, action

class unblock_machine:

    hours = 0
    minutes = 0
    lock = False
    user_found = False
    user_credit = 0
    user_id = None
    pre_paid = False

    def __init__(self, currency, price_per_hour, users_manager, Parent=None):

        self.xml = get_gtk_builder('unblock_machine')
        self.dialog = self.xml.get_object("dialog")
        self.price_per_hour = price_per_hour
        self.users_manager = users_manager
        self.currency = currency

        self._user_entry_timeout_id = 0

        if Parent:
            self.dialog.set_transient_for(Parent)

        self.unregistred_radio = self.xml.get_object('unregistred_radio')
        self.registred_radio = self.xml.get_object('registred_radio')
        self.total_to_pay = self.xml.get_object("total_to_pay")
        self.warning_label = self.xml.get_object("warning_label")
        self.user_entry = self.xml.get_object("user_entry")
        self.unlimited_radio = self.xml.get_object("unlimited_radio")
        self.limited_radio = self.xml.get_object("limited_radio")
        self.prepaid = self.xml.get_object("prepaid")
        self.xml.get_object("user_status").set_from_file(None)
        self.xml.get_object("hourly_rate").set_value(price_per_hour)

        #EntryCompletion
        self.entry_completion = gtk.EntryCompletion()
        self.entry_list_store = gtk.ListStore(gobject.TYPE_STRING,
                                              gobject.TYPE_STRING)



        render_name = gtk.CellRendererText()
        self.entry_completion.pack_start(render_name, expand=True)
        self.entry_completion.add_attribute(render_name, "text", 0)

        render_nick = gtk.CellRendererText()
        self.entry_completion.pack_start(render_nick, expand=False)
        self.entry_completion.add_attribute(render_nick, "text", 1)

        self.entry_completion.set_property('text_column', 1)

        self.entry_completion.set_model(self.entry_list_store)
        self.entry_completion.set_match_func(self.entry_completion_match_func)
        self.user_entry.set_completion(self.entry_completion)
        self.populate_list_store()
        self.user_entry.connect("changed", self.on_user_entry_changed)

        self.xml.connect_signals(self)

    def populate_list_store(self):
	
        for user in self.users_manager.get_all().filter_by(logado=False).all():
            try:
                user_block = self.manager.block_manager.get_all().filter_by(user=user.id).one()
            except:
                self.entry_list_store.append((user.nick, user.full_name))

    def entry_completion_match_func(self, completion, key, iter):

        model = completion.get_model()
        full_name = model.get_value(iter, 0)
        nick = model.get_value(iter, 1)

        if nick.startswith(key) or full_name.lower().startswith(key):
            return True

        return False

    def on_unregistred_radio_toggled(self, obj):
        if obj.get_active():
            self.limited_radio.set_active(True)
            self.unlimited_radio.set_sensitive(False)
            self.xml.get_object("registred_table").set_sensitive(False)
            self.xml.get_object("prepaid").set_sensitive(True)
        else:
            self.unlimited_radio.set_sensitive(True)
            self.xml.get_object("registred_table").set_sensitive(True)
	    self.xml.get_object("prepaid").set_sensitive(False)

        self.check_credit()

    def on_limited_radio_toggled(self, obj):
        self.xml.get_object("time_alignment").set_sensitive(obj.get_active())
        self.check_credit()

    def on_hourly_rate_value_changed(self, obj):
        self.price_per_hour = obj.get_value()
        self.on_total_to_pay_value_changed(self.total_to_pay)

    def on_spin_button_output(self, obj):
        obj.set_text("%02d" % obj.get_adjustment().get_value())
        return True

    def on_hour_value_changed(self, obj):
        self.hours = obj.get_value_as_int()
        self.update_total_to_pay()

    def on_minutes_value_changed(self, obj):
        self.minutes = obj.get_value_as_int()
        self.update_total_to_pay()

    def update_total_to_pay(self):
        if not self.lock:
            self.lock = True
            t = calculate_credit(self.price_per_hour,
                                 self.hours,
                                 self.minutes)

            self.total_to_pay.set_value(t)
            self.lock = False

    def check_credit(self):

        t = self.total_to_pay.get_value()

        if (self.registred_radio.get_active() and
            (self.unlimited_radio.get_active() and self.user_found
             and self.user_credit == 0 and t > self.user_credit)):

            self.xml.get_object('warning_hbox').show()
            color_entry(self.total_to_pay, COLOR_YELLOW)
            self.warning_label.set_text(
                    _("Voce nao possui creditos suficientes!"))

            credit_ok = False

        else:
            self.xml.get_object('warning_hbox').hide()
            color_entry(self.total_to_pay, None)
            self.warning_label.set_text("")

            credit_ok = True

        total_to_pay = self.total_to_pay.get_value()

        if ((self.registred_radio.get_active() and self.user_found
                and credit_ok) and
            ((self.limited_radio.get_active() and total_to_pay)
                or self.unlimited_radio.get_active()) or
            (self.unregistred_radio.get_active() and total_to_pay)):
            status = True
        else:
            status = False

        self.xml.get_object('apply_button').set_sensitive(status)

    def on_total_to_pay_value_changed(self, obj):

        self.check_credit()

        if not self.lock:
            self.lock = True
            t = obj.get_value()

            hour, minutes = calculate_time(self.price_per_hour, t)
            self.xml.get_object('hour').set_value(hour)
            self.xml.get_object('minutes').set_value(minutes)

            self.lock = False

    def on_user_entry_changed(self, obj):

        if self._user_entry_timeout_id > 0:
            gobject.source_remove(self._user_entry_timeout_id)

        timeout = 1000
        #calculate_time
        self._user_entry_timeout_id = gobject.timeout_add(timeout,
                                    self.on_user_entry_changed_done)

    def on_user_entry_changed_done(self):
        nick = self.user_entry.get_text()
        out = self.users_manager.check_user_logado(nick)

        if not out:
	    out = self.users_manager.get_credit_and_id(nick)
	    if out:
               self.user_credit = out[0]
               self.user_id = out[1]
               self.xml.get_object('credit').set_text(
                       _("%s %0.2f of credit") % (self.currency,
                                                  self.user_credit)
                       )

               self.user_found = True


            elif nick == "":
               self.user_found = False
               self.xml.get_object('credit').set_text("")

            else:
               self.user_found = False
               self.xml.get_object('credit').set_text(_("Usuario nao encontrado ou bloqueado para utilizacao."))
	else:
               self.user_found = False
               self.xml.get_object('credit').set_text(_("Usuario já está sendo utilizado."))

        self.check_credit()

    def run(self):

        resp = self.dialog.run()

        if resp:
            total_time = (
                    self.xml.get_object('hour').get_value_as_int(),
                    self.xml.get_object('minutes').get_value_as_int())


            data = {
                    'registred': self.registred_radio.get_active(),
                    'limited': self.limited_radio.get_active(),
                    'pre_paid': self.xml.get_object('prepaid').get_active(),
                    'price_per_hour': self.xml.get_object('hourly_rate').get_value()
                   }

            if data['registred']:
                data['user_id'] = self.user_id
            else:
                data['user_id'] = None

            if data['limited']:
                data['time'] = total_time
            else:
                data['time'] = None

            self.dialog.destroy()

            return data

        self.dialog.destroy()

class NewCashFlowItem:

    user_id = None
    user_found = True

    def __init__(self, users_manager, Parent=None):
        self.users_manager = users_manager
        self._user_entry_timeout_id = 0

        self.xml = get_gtk_builder('cash_flow_new_item')
        self.dialog = self.xml.get_object("dialog")
        self.user_nick = self.xml.get_object("user_nick")
        self.xml.get_object("type_combobox").set_active(0)

        #EntryCompletion
        self.entry_completion = gtk.EntryCompletion()
        self.entry_list_store = gtk.ListStore(gobject.TYPE_STRING,
                                              gobject.TYPE_STRING)

        render_name = gtk.CellRendererText()
        self.entry_completion.pack_start(render_name, expand=True)
        self.entry_completion.add_attribute(render_name, "text", 0)

        render_nick = gtk.CellRendererText()
        self.entry_completion.pack_start(render_nick, expand=False)
        self.entry_completion.add_attribute(render_nick, "text", 1)

        self.entry_completion.set_property('text_column', 1)

        self.entry_completion.set_model(self.entry_list_store)
        self.entry_completion.set_match_func(self.entry_completion_match_func)
        self.user_nick.set_completion(self.entry_completion)
	self.populate_list_store()
	self.user_nick.connect("changed", self.on_user_entry_changed)


        if Parent:
            self.dialog.set_transient_for(Parent)

        self.xml.connect_signals(self)

    def populate_list_store(self):
        for user in self.users_manager.get_all():
            self.entry_list_store.append((user.nick, user.full_name))

    def entry_completion_match_func(self, completion, key, iter):

        model = completion.get_model()
        full_name = model.get_value(iter, 0)
        nick = model.get_value(iter, 1)

        if nick.startswith(key) or full_name.lower().startswith(key):
            return True

        return False

    def on_user_entry_changed(self, obj):

        if self._user_entry_timeout_id > 0:
            gobject.source_remove(self._user_entry_timeout_id)

        #resp = self.dialog.run()

        #if resp:
	#    try:
        #        total_time = (
        #              self.xml.get_object('hour').get_value_as_int(),
        #              self.xml.get_object('minutes').get_value_as_int())
        #    except:
        # 	 total_time = 0

        #    return total_time

        #self.dialog.destroy()
        timeout = 1000

        self._user_entry_timeout_id = gobject.timeout_add(timeout,
                                    self.on_user_entry_changed_done)

    def on_user_entry_changed_done(self):
	nick = self.user_nick.get_text()
	out = self.users_manager.get_credit_and_id(nick)

        if out:
            self.user_id = out[1]
	    self.user_found = True
            self.xml.get_object("label_warning").hide()
            self.xml.get_object("warning_image").hide()

        elif nick == "":
            self.user_found = False
            self.xml.get_object("label_warning").hide()
            self.xml.get_object("warning_image").hide()

        else:
            self.user_found = False
            self.xml.get_object("label_warning").show()
            self.xml.get_object("warning_image").show()

        self.check_status()

    def on_checkbutton_toggled(self, obj):
        self.xml.get_object("user_nick").set_sensitive(obj.get_active())
        self.check_status()

    def on_value_spinbutton_value_changed(self, obj):
        self.check_status()

    def check_status(self):
        user_status = self.xml.get_object("checkbutton").get_active()
        value = self.xml.get_object("value_spinbutton").get_value()

        if ((value and not(user_status)) or
            (value and user_status and self.user_found)):
            status = True
        else:
            status = False

        self.xml.get_object("ok_button").set_sensitive(status)

    def run(self):
        if self.dialog.run():
            data = {
                'type': self.xml.get_object("type_combobox").get_active(),
                'value': self.xml.get_object("value_spinbutton").get_value(),
                }

            bf = self.xml.get_object("notes_textview").get_buffer()
            data['notes'] = bf.get_text(bf.get_start_iter(), bf.get_end_iter())

            if self.xml.get_object("checkbutton").get_active():
                data['user_id'] = self.user_id

            self.dialog.destroy()
            return data

        self.dialog.destroy()

class machine_info:
    def __init__(self, Parent=None):

        xml = get_gtk_builder('machine_info')

        self.dialog = xml.get_object('dialog')
        self.name = xml.get_object('name')
        self.mac = xml.get_object('mac')
        self.ip = xml.get_object('ip')
        self.hostname = xml.get_object('hostname')
        self.last_user = xml.get_object('last_user')
        self.textview = xml.get_object('textview')
        self.os = xml.get_object('os')

        xml.connect_signals(self)

        self.xml = xml

        if Parent:
            self.dialog.set_transient_for(Parent)

    def on_os_changed(self, machine_inst, os_name, os_version):
        self.os.set_text("%s %s" % (os_name, os_version))

    def on_source_changed(self, machine_inst, source):
        if source:
            self.source.set_text(source)
        else:
            self.source.set_text("")

    def run(self, machine_inst, last_user=None):
        self.dialog.set_title(_('%s Properties') % machine_inst.name)
        self.name.set_text(machine_inst.name)
        self.mac.set_text(machine_inst.mac)
        self.ip.set_text(machine_inst.ip)
        self.hostname.set_text(machine_inst.hostname)
        self.os.set_text("%s %s" % (machine_inst.os_name,
                                    machine_inst.os_version))

        os_changed_id = machine_inst.connect("os_changed",
                                          self.on_os_changed)

        #source_changed_id = machine_inst.connect("source_changed",
        #                                         self.on_source_changed)

        #if machine_inst.source:
        #    self.source.set_text(machine_inst.source)

        bf = self.textview.get_buffer()
        bf.set_text(machine_inst.description)

        if last_user:
            self.xml.get_object("last_user").set_text(last_user)

        self.dialog.run()
        gobject.source_remove(os_changed_id)
        #gobject.source_remove(source_changed_id)
        self.dialog.destroy()


class unblock_date:

    hours = 0
    minutes = 0
    lock = False

    def __init__(self, currency, nick, maquina, Parent=None):

        self.xml = get_gtk_builder('unblock_date')
        self.dialog = self.xml.get_object("dialog")
        self.currency = currency
        self.resp = ""
        self.user_nick = nick

        if Parent:
            self.dialog.set_transient_for(Parent)

        status = False
        self.xml.get_object('user').set_text(self.user_nick)
        self.xml.get_object('maquina').set_text(maquina)
        self.xml.get_object('apply_button').set_sensitive(status)
        self.xml.connect_signals(self)
	
    def on_spin_button_output(self, obj):
        obj.set_text("%02d" % obj.get_adjustment().get_value())
        return True

    def on_hour_value_changed(self, obj):
        self.hours = obj.get_value_as_int()

	if self.hours > 0:
	   self.xml.get_object('apply_button').set_sensitive(True)
	else:
	   self.xml.get_object('apply_button').set_sensitive(False)

    def on_minutes_value_changed(self, obj):
        self.minutes = obj.get_value_as_int()

        if self.minutes > 0:
	   self.xml.get_object('apply_button').set_sensitive(True)
	else:
	   self.xml.get_object('apply_button').set_sensitive(False)


    def on_cancel_button_clicked(self, obj):
        self.dialog.destroy()

    def run(self):

        resp = self.dialog.run()

        if resp:
            total_time = (
                    self.xml.get_object('hour').get_value_as_int(),
                    self.xml.get_object('minutes').get_value_as_int())

            self.dialog.destroy()

            return total_time

        self.dialog.destroy()


class add_time:

    lock = False

    def __init__(self, price_per_hour, Parent=None):

        self.price_per_hour = price_per_hour

        self.xml = get_gtk_builder('add_time')
        self.dialog = self.xml.get_object('add_time')
        self.table = self.xml.get_object('table')
        self.add_button = self.xml.get_object('add_button')
        self.price = self.xml.get_object('price')

        self.hour_entry = HourEntry.HourEntry()
        #self.hour_entry.set_second_visible(False)
        self.hour_entry.show()
        self.hour_entry.connect('time_changed', self.time_changed)
        self.table.attach(child=self.hour_entry,
                          left_attach=1, right_attach=2,
                          top_attach=0, bottom_attach=1)

        self.xml.connect_signals(self)

        if Parent:
            self.dialog.set_transient_for(Parent)

    def price_changed(self, obj):
        if not self.lock:
            self.lock = True
            value = obj.get_value()
            self.add_button.set_sensitive(bool(value))
            tm = calculate_time(self.price_per_hour, value)
            self.hour_entry.set_time(*tm)
            self.lock = False

    def time_changed(self, obj):
        if not self.lock:
            self.lock = True
            t = obj.get_time()
            value = calculate_credit(self.price_per_hour, *t)
            self.add_button.set_sensitive(bool(value))
            self.price.set_value(value)
            self.lock = False

    def run(self):
        a_time = None

        if self.dialog.run():
            a_time = self.hour_entry.get_time()


        self.dialog.destroy()
        return a_time

class remove_time:

    lock = False

    def __init__(self, price_per_hour, Parent=None):

        self.price_per_hour = price_per_hour

        self.xml = get_gtk_builder('remove_time')
        self.dialog = self.xml.get_object('remove_time')
        self.table = self.xml.get_object('table')
        self.remove_button = self.xml.get_object('remove_button')
        self.price = self.xml.get_object('price')

        self.hour_entry = HourEntry.HourEntry()
        #self.hour_entry.set_second_visible(False)
        self.hour_entry.show()
        self.hour_entry.connect('time_changed', self.time_changed)
        self.table.attach(child=self.hour_entry,
                          left_attach=1, right_attach=2,
                          top_attach=0, bottom_attach=1)

        self.xml.connect_signals(self)

        if Parent:
            self.dialog.set_transient_for(Parent)

    def price_changed(self, obj):
        if not self.lock:
            self.lock = True
            value = obj.get_value()
            self.remove_button.set_sensitive(bool(value))
            tm = calculate_time(self.price_per_hour, value)
            self.hour_entry.set_time(*tm)
            self.lock = False

    def time_changed(self, obj):
        if not self.lock:
            self.lock = True
            t = obj.get_time()
            value = calculate_credit(self.price_per_hour, *t)
            self.remove_button.set_sensitive(bool(value))
            self.price.set_value(value)
            self.lock = False

    def run(self):
        a_time = None

        if self.dialog.run():
            a_time = self.hour_entry.get_time()

        self.dialog.destroy()
        return a_time

class history:
    search_text = ""

    def __init__(self, history_manager, Parent=None):
        self.history_manager = history_manager
        self.xml = get_gtk_builder('history')

        self.dialog = self.xml.get_object('history')
        self.dialog.set_default_size(600, 300)
        self.treeview = self.xml.get_object("treeview")
        self.calendar = self.xml.get_object("calendar")
        self.search_entry = SearchEntry(gtk.icon_theme_get_default())
        self.search_entry.show()

        self.search_entry.connect("terms-changed",
                                  self.on_search_entry_terms_changed)

        self.xml.get_object("filter_hbox").pack_start(self.search_entry)

        #TreeView
        model = gtk.ListStore(gobject.TYPE_INT,
                              gobject.TYPE_STRING,
                              gobject.TYPE_STRING,
                              gobject.TYPE_STRING,
                              gobject.TYPE_STRING,
                              )

        #ID
        column = gtk.TreeViewColumn(_("ID"), gtk.CellRendererText(), text=0)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(0)
        column.set_resizable(False)
        column.set_expand(False)
        column.set_visible(False)

        self.treeview.append_column(column)

        #Time
        column = gtk.TreeViewColumn(_("Time"), gtk.CellRendererText(), text=1)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(1)
        column.set_resizable(True)
        column.set_expand(False)

        self.treeview.append_column(column)

        #Start Time
        column = gtk.TreeViewColumn(_("Start Time"), gtk.CellRendererText(), text=2)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(2)
        column.set_resizable(True)
        column.set_expand(False)

        self.treeview.append_column(column)

        #End Time
        column = gtk.TreeViewColumn(_("End Time"), gtk.CellRendererText(), text=3)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(3)
        column.set_resizable(True)
        column.set_expand(False)

        self.treeview.append_column(column)

        #User
        column = gtk.TreeViewColumn(None, gtk.CellRendererText(), text=4)
        column.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
        column.set_reorderable(True)
        column.set_clickable(True)
        column.set_sort_column_id(4)
        column.set_resizable(True)
        column.set_expand(False)

        self.treeview.append_column(column)
        self.name_column = column

        self.model = model
        self.model_filtered = self.model.filter_new()
        self.model_filtered.set_visible_func(self.on_model_visible_cb)
        self.model_sortable = gtk.TreeModelSort(self.model_filtered)
        self.treeview.set_model(self.model_sortable)
        self.xml.connect_signals(self)

        if Parent:
            self.dialog.set_transient_for(Parent)

    def on_search_entry_terms_changed(self, obj, text):
        self.search_text = text
        self.model_filtered.refilter()

    def on_model_visible_cb(self, model, iter):
        if self.search_text == "":
            return True

        t = False
        for col in (4,):
            x = model.get_value(iter, col)
            if x and self.search_text in x:
                t = True
                break

        return t

    def on_history_insert(self, obj, item):
        year, month, day = self.calendar.get_date()
        month += 1 #Change range(0, 11) to range(1, 12)

        if item.month==month and item.year==year:
            self.calendar.mark_day(item.day)

            if item.day==day:
                self.treeview.set_sensitive(True)
                self.append_item(item)

class machine_history(history):
    def __init__(self, history_manager, users_manager, Parent=None):
        history.__init__(self, history_manager, Parent)
        self.users_manager = users_manager
        self.name_column.set_title(_("User"))

    def append_item(self, item):
        user_fullname = self.users_manager.get_full_name(item.user_id)

        if user_fullname:
            username = user_fullname
        else:
            username = _("Unknown user")

        self.model.append((item.id, item.time,
                           item.start_time,
                           item.end_time, username))

    def populate(self, year, month, day, machine_mac):

        self.model.clear()

        kwargs = {'year': year, 'month': month, 'day': day,
                  'mac': machine_mac}

        sensitive = False

        for item in self.history_manager.get_all().filter_by(**kwargs):
            sensitive = True
            self.append_item(item)

        self.treeview.set_sensitive(sensitive)

    def on_day_selected(self, obj):
        year, month, day = self.calendar.get_date()
        month += 1 #Change range(0, 11) to range(1, 12)

        self.populate(year, month, day, self.machine_inst.mac)

    def on_month_changed(self, obj):
        year, month, day = self.calendar.get_date()
        month += 1 #Change range(0, 11) to range(1, 12)

        days = self.history_manager.get_days_for_machine_id(year,
                                                month, self.machine_inst.mac)

        obj.clear_marks()

        for day in days:
            obj.mark_day(day)

    def run(self, machine_inst):
        self.history_manager.connect('insert',
                                     self.on_history_insert)
        self.machine_inst = machine_inst
        self.dialog.set_title(_("History of %s") % machine_inst.name)

        self.on_month_changed(self.calendar)
        self.on_day_selected(self.calendar)

        self.dialog.run()
        self.dialog.destroy()
        self.history_manager.disconnect_by_func(self.on_history_insert)

class user_history(history):
    def __init__(self, history_manager, machine_manager, Parent=None):
        history.__init__(self, history_manager, Parent)
        self.machine_manager = machine_manager
        self.name_column.set_title(_("Machine"))

    def append_item(self, item):
        machineName = self.machine_manager.get_name_mac(item.mac)

        if machineName:
            machine_name = machineName
        else:
            machine_name = _("Maquina nao encontrada")

        self.model.append((item.id, item.time,
                           item.start_time,
                           item.end_time, machine_name))

    def populate(self, year, month, day, user_id):

        self.model.clear()

        kwargs = {'year': year, 'month': month, 'day': day,
                  'user_id': user_id}

        sensitive = False

        for item in self.history_manager.get_all().filter_by(**kwargs):
            sensitive = True
            self.append_item(item)

        self.treeview.set_sensitive(sensitive)

    def on_day_selected(self, obj):
        year, month, day = self.calendar.get_date()
        month += 1 #Change range(0, 11) to range(1, 12)

        self.populate(year, month, day, self.user_id)

    def on_month_changed(self, obj):
        year, month, day = self.calendar.get_date()
        month += 1 #Change range(0, 11) to range(1, 12)

        days = self.history_manager.get_days_for_user_id(year,
                                                month, self.user_id)

        obj.clear_marks()

        for day in days:
            obj.mark_day(day)

    def run(self, user_id, user_name):
        self.history_manager.connect('insert',
                                     self.on_history_insert)
        self.user_id = user_id
        self.dialog.set_title(_("History of %s") % user_name)

        self.on_month_changed(self.calendar)
        self.on_day_selected(self.calendar)

        self.dialog.run()
        self.dialog.destroy()
        self.history_manager.disconnect_by_func(self.on_history_insert)

class clear_history:
    def __init__(self, Parent):
        self.xml = get_gtk_builder('clear_history')
        self.dialog = self.xml.get_object('clear_history')
        self.month = self.xml.get_object('month')
        self.year = self.xml.get_object('year')

        year, month = localtime()[0:2]

        self.year.set_value(year)
        self.month.set_active(month)

        self.xml.connect_signals(self)

        if Parent:
            self.dialog.set_transient_for(Parent)

    def on_all_entries_toggled(self, obj):
        self.xml.get_object("alignment").set_sensitive(not obj.get_active())

    def run(self):
        data = None

        if self.dialog.run():
            all_entries = self.xml.get_object("allentries").get_active()
            year = int(self.year.get_value())
            month = self.month.get_active()
            data = all_entries, year, month

        self.dialog.destroy()

        return data

class set_price_per_hour:
    def __init__(self, Parent=None):
        self.xml = get_gtk_builder('set_price_per_hour')
        self.dialog = self.xml.get_object('dialog')
        self.apply_button = self.xml.get_object('button2')
        self.price_per_hour = self.xml.get_object('price_per_hour')
        self.xml.connect_signals(self)

        if Parent:
            self.dialog.set_transient_for(Parent)

    def on_price_changed(self, obj):
        self.apply_button.set_sensitive(bool(
                obj.get_value()))

    def run(self):
        price = None
        if self.dialog.run():
            price = self.price_per_hour.get_value()
            #este valor nao pode ser 0 pois gera erro quando é gerada a cobranca
            if price == 0:
                price = 0.01

        self.dialog.destroy()

        return price



class MachineCategory:
    def __init__(self, Parent=None):
        self.xml = get_gtk_builder('add_machine_category')

        self.dialog = self.xml.get_object('add_machine_category')

        self.background_chooser = image_chooser_button()
        self.logo_chooser = image_chooser_button()

        self.background_chooser.set_sensitive(False)
        self.logo_chooser.set_sensitive(False)

        background_chooser_btn = self.background_chooser.get_children()[0]
        logo_chooser_btn = self.logo_chooser.get_children()[0]

        #pack start
        self.xml.get_object('lock_box').attach(self.background_chooser, 1, 2, 0, 1,
                    xoptions=gtk.FILL|gtk.EXPAND, xpadding=0, ypadding=0)

        self.xml.get_object('lock_box').attach(self.logo_chooser, 1, 2, 1, 2,
                    xoptions=gtk.FILL|gtk.EXPAND, xpadding=0, ypadding=0)

        self.background_chooser.show()
        self.logo_chooser.show()

        self.xml.connect_signals(self)

        if Parent:
            self.dialog.set_transient_for(Parent)

    def on_name_entry_changed(self, obj):
        self.xml.get_object('okbnt').set_sensitive(bool(obj.get_text()))

    def background_bnt_toggled_cb(self, obj):
        self.background_chooser.set_sensitive(obj.get_active())

    def on_logo_bnt_toggled(self, obj):
        self.logo_chooser.set_sensitive(obj.get_active())

    def on_hourly_rate_toggled(self, obj):
        self.xml.get_object('price_hour').set_sensitive(obj.get_active())

    def set_category(self, category):
        if category.name:
            self.xml.get_object('name_entry').set_text(category.name)

        if category.custom_logo:
            self.xml.get_object('logo_bnt').set_active(True)

        if category.custom_background:
            self.xml.get_object('background_bnt').set_active(True)

        if category.custom_price_hour:
            self.xml.get_object('custom_hourly_rate').set_active(True)

        if category.price_hour:
            self.xml.get_object('price_hour').set_value(category.price_hour)

        if category.logo_path:
            self.logo_chooser.set_filename(category.logo_path)

        if category.background_path:
            self.background_chooser.set_filename(category.background_path)


    def run(self, category=None):

        if category:
            self.set_category(category)
            self.dialog.set_title("Edição de categoria de maquina")

        if self.dialog.run():
            data = {}
            data['name'] = self.xml.get_object('name_entry').get_text()
            data['custom_logo'] = self.xml.get_object('logo_bnt').get_active()
            data['custom_background'] = self.xml.get_object('background_bnt').get_active()
            data['custom_price_hour'] = self.xml.get_object("custom_hourly_rate").get_active()

            if ('custom_price_hour' in data) and data['custom_price_hour']:
                data['price_hour'] = self.xml.get_object('price_hour').get_value()

            if ('custom_logo' in data) and data['custom_logo']:
                data['logo_path'] = self.logo_chooser.get_filename()

            if ('custom_background' in data) and data['custom_background']:
                data['background_path'] = self.background_chooser.get_filename()

            self.dialog.destroy()

            return data
        else:
            self.dialog.destroy()


class UserCategory:
    def __init__(self, Parent=None):
        self.xml = get_gtk_builder('add_user_category')

        self.dialog = self.xml.get_object('add_user_category')
        self.xml.connect_signals(self)

        if Parent:
            self.dialog.set_transient_for(Parent)

    def on_name_entry_changed(self, obj):
        self.xml.get_object('okbnt').set_sensitive(bool(obj.get_text()))

    def on_hourly_rate_toggled(self, obj):
        self.xml.get_object('price_hour').set_sensitive(obj.get_active())

    def set_category(self, category):
        if category.name:
            self.xml.get_object('name_entry').set_text(category.name)

        if category.custom_price_hour:
            self.xml.get_object('custom_hourly_rate').set_active(True)

        if category.price_hour:
            self.xml.get_object('price_hour').set_value(category.price_hour)

        if category.allow_login:
            self.xml.get_object('allow_login').set_active(True)

    def run(self, category=None):

        if category:
            self.set_category(category)
            self.dialog.set_title("Edição de categoria de usuario")

        if self.dialog.run():
            data = {}
            data['name'] = self.xml.get_object('name_entry').get_text()
            data['price_hour'] = self.xml.get_object('price_hour').get_value()

            data['custom_price_hour'] = self.xml.get_object("custom_hourly_rate").get_active()

            if ('custom_price_hour' in data) and data['custom_price_hour']:
                data['price_hour'] = self.xml.get_object('price_hour').get_value()

            data['allow_login'] = self.xml.get_object("allow_login").get_active()
            data['time_limit_machine'] = datetime.datetime.now()
            self.dialog.destroy()

            return data
        else:
            self.dialog.destroy()

class SelectMachineCategory:

    category = 0

    def __init__(self, machine_category_manager, Parent=None):

        self.machine_category_manager = machine_category_manager

        self.xml = get_gtk_builder('select_machine_category')
        self.dialog = self.xml.get_object("dialog")

        if Parent:
            self.dialog.set_transient_for(Parent)

        combobox = self.xml.get_object("combobox")
        combobox.set_active(0)
        combobox.set_row_separator_func(self.row_separator_func)

        model = combobox.get_model()
        model.append((-1, ""))

        if self.machine_category_manager:
            for i in self.machine_category_manager.get_all():
                model.append((i.id, i.name))

        self.xml.connect_signals(self)

    def row_separator_func(self, model, iter):

        if model.get_value(iter, 0) == -1:
            return True
        else:
            return False

    def run(self):
        if self.dialog.run():
            combobox = self.xml.get_object("combobox")
            model = combobox.get_model()
            iter = combobox.get_active_iter()
            self.category = model.get_value(iter, 0)
            self.dialog.destroy()

            return True

        self.dialog.destroy()


class BloquearSite:
    def __init__(self, Parent=None):
        self.conf_client = get_default_client()
        self.xml = get_gtk_builder('add_block_site')
        self.dialog = self.xml.get_object("dialog")

        self.treeview = self.xml.get_object("treeview")

        self.ListStore = gtk.ListStore(gobject.TYPE_STRING)
        self.treeview.set_model(self.ListStore)

        self.renderer = gtk.CellRendererText()
        self.renderer.set_property("editable", True)
        self.renderer.connect("edited", self.column_edited)
        self.column = gtk.TreeViewColumn(_("Sites"),
                                         self.renderer,
                                         text=0)

        self.treeview.append_column(self.column)

        if Parent:
            self.dialog.set_transient_for(Parent)

        self.xml.connect_signals(self)

        #Populate apps

	try:
	   f_texto = open("/etc/squid/sitesbloqueados.txt","r")

	   for site in f_texto.readlines():
	     var = ""
	
	     var = string.strip(site)

	     if "#" in var:
		continue

             self.ListStore.append((var,))

	except:	
   	    pass

	f_texto.close()


    def column_edited(self, renderer, path_string, text):

        iter = self.ListStore.get_iter_from_string(path_string)
        old_text = self.ListStore.get_value(iter, 0)

        # not accept spaces
        if text == _("Site name"):
            self.ListStore.remove(iter)
            return

	#if "#" in app_name:
	#    continue

        if " " in text:
            text = text.split(" ")[0]

        if not(text):
            if old_text == _("Site name"):
                self.ListStore.remove(iter)
            return

        # remove iter


        self.ListStore.set_value(iter, 0, text)

    def on_add_button_clicked(self, obj):
        iter = self.ListStore.append((_("Site name"),))
        path = self.ListStore.get_path(iter)
        self.treeview.set_cursor_on_cell(path, self.column,
                                         self.renderer,
                                         start_editing=True)

    def on_remove_button_clicked(self, obj):
        cursor = self.treeview.get_cursor()
        iter = self.ListStore.get_iter(cursor[0])
        self.ListStore.remove(iter)
        self.treeview.grab_focus()

    def run(self):
        self.dialog.run()

        # save apps
        apps = []
	f_texto = open("/etc/squid/sitesbloqueados.txt","w")
        for i in self.ListStore:
            app_name = i[0]

            if app_name == _("Site name"):
                continue
	
	    if "#" in app_name:
		continue

            if " " in app_name:
                app_name = app_name.split(" ")[0]

            apps.append(app_name)
	    f_texto.write(app_name+'\n')

	f_texto.close()
	os.system("squid -k reconfigure")

        self.dialog.destroy()

class BloquearPalavra:
    def __init__(self, Parent=None):
        self.conf_client = get_default_client()
        self.xml = get_gtk_builder('add_bloquear_palavra')
        self.dialog = self.xml.get_object("dialog")

        self.treeview = self.xml.get_object("treeview")

        self.ListStore = gtk.ListStore(gobject.TYPE_STRING)
        self.treeview.set_model(self.ListStore)

        self.renderer = gtk.CellRendererText()
        self.renderer.set_property("editable", True)
        self.renderer.connect("edited", self.column_edited)
        self.column = gtk.TreeViewColumn(_("Palavras"),
                                         self.renderer,
                                         text=0)

        self.treeview.append_column(self.column)

        if Parent:
            self.dialog.set_transient_for(Parent)

        self.xml.connect_signals(self)

        #Populate apps

	try:
	   f_texto = open("/etc/squid/palavrasbloqueadas.txt","r")

	   for site in f_texto.readlines():
	     var = ""

	     var = string.strip(site)

             if "#" in var:
		continue

             self.ListStore.append((var,))

	except:	
	    dialogs.ok_only(_("<b><big>Bloqueio de palavras</big></b>\n\n"
                              "Não foi possível realizar o bloqueio por palavras. Arquivo não encontrado!"),
                               Parent=self.mainwindow,
                               ICON=gtk.MESSAGE_ERROR)
   	    return

	f_texto.close()


    def column_edited(self, renderer, path_string, text):

        iter = self.ListStore.get_iter_from_string(path_string)
        old_text = self.ListStore.get_value(iter, 0)

        # not accept spaces
        if text == _("Palavra name"):
            self.ListStore.remove(iter)
            return

        if " " in text:
            text = text.split(" ")[0]

        if not(text):
            if old_text == _("Palavra name"):
                self.ListStore.remove(iter)
            return

        # remove iter


        self.ListStore.set_value(iter, 0, text)

    def on_add_button_clicked(self, obj):
        iter = self.ListStore.append((_("Palavra name"),))
        path = self.ListStore.get_path(iter)
        self.treeview.set_cursor_on_cell(path, self.column,
                                         self.renderer,
                                         start_editing=True)

    def on_remove_button_clicked(self, obj):
        cursor = self.treeview.get_cursor()
        iter = self.ListStore.get_iter(cursor[0])
        self.ListStore.remove(iter)
        self.treeview.grab_focus()

    def run(self):
        self.dialog.run()

        # save apps
        apps = []
	f_texto = open("/etc/squid/palavrasbloqueadas.txt","w")
        for i in self.ListStore:
            app_name = i[0]

            if app_name == _("Palavra name"):
                continue

	    if "#" in app_name:
		continue

            if " " in app_name:
                app_name = app_name.split(" ")[0]

            apps.append(app_name)
	    f_texto.write(app_name+'\n')

	f_texto.close()
	os.system("squid -k reconfigure")

        self.dialog.destroy()
		

class EditCloseApplications:
    def __init__(self, Parent=None):
        self.conf_client = get_default_client()
        self.xml = get_gtk_builder('edit_close_apps')
        self.dialog = self.xml.get_object("dialog")

        self.treeview = self.xml.get_object("treeview")

        self.ListStore = gtk.ListStore(gobject.TYPE_STRING)
        self.treeview.set_model(self.ListStore)

        self.renderer = gtk.CellRendererText()
        self.renderer.set_property("editable", True)
        self.renderer.connect("edited", self.column_edited)
        self.column = gtk.TreeViewColumn(_("Applications"),
                                         self.renderer,
                                         text=0)

        self.treeview.append_column(self.column)

        if Parent:
            self.dialog.set_transient_for(Parent)

        self.xml.connect_signals(self)

        #Populate apps
        for a in self.conf_client.get_string_list("close_apps_list"):
            self.ListStore.append((a,))

    def column_edited(self, renderer, path_string, text):

        iter = self.ListStore.get_iter_from_string(path_string)
        old_text = self.ListStore.get_value(iter, 0)

        # not accept spaces
        if text == _("Application name"):
            self.ListStore.remove(iter)
            return

        if " " in text:
            text = text.split(" ")[0]

        if not(text):
            if old_text == _("Application name"):
                self.ListStore.remove(iter)
            return

        # remove iter


        self.ListStore.set_value(iter, 0, text)

    def on_add_button_clicked(self, obj):
        iter = self.ListStore.append((_("Application name"),))
        path = self.ListStore.get_path(iter)
        self.treeview.set_cursor_on_cell(path, self.column,
                                         self.renderer,
                                         start_editing=True)

    def on_remove_button_clicked(self, obj):
        cursor = self.treeview.get_cursor()
        iter = self.ListStore.get_iter(cursor[0])
        self.ListStore.remove(iter)
        self.treeview.grab_focus()

    def run(self):
        self.dialog.run()

        # save apps
        apps = []
        for i in self.ListStore:
            app_name = i[0]

            if app_name == _("Application name"):
                continue

            if " " in app_name:
                app_name = app_name.split(" ")[0]

            apps.append(app_name)

        self.conf_client.set_string_list("close_apps_list",
                                         apps)

        self.dialog.destroy()

class NewDebt:
    def __init__(self, users_manager, Parent=None):
        self.xml = get_gtk_builder('add_opendebt')
        self.dialog = self.xml.get_object("dialog")

        self.users_manager = users_manager

        self._user_entry_timeout_id = 0

        if Parent:
            self.dialog.set_transient_for(Parent)

        self.total_to_pay = self.xml.get_object("total_to_pay")
        self.warning_label = self.xml.get_object("warning_label")
        self.user_entry = self.xml.get_object("user_entry")
        self.xml.get_object("user_status").set_from_file(None)

        #EntryCompletion
        self.entry_completion = gtk.EntryCompletion()
        self.entry_list_store = gtk.ListStore(gobject.TYPE_STRING,
                                              gobject.TYPE_STRING)


        render_name = gtk.CellRendererText()
        self.entry_completion.pack_start(render_name, expand=True)
        self.entry_completion.add_attribute(render_name, "text", 0)

        render_nick = gtk.CellRendererText()
        self.entry_completion.pack_start(render_nick, expand=False)
        self.entry_completion.add_attribute(render_nick, "text", 1)

        self.entry_completion.set_property('text_column', 1)

        self.entry_completion.set_model(self.entry_list_store)
        self.entry_completion.set_match_func(self.entry_completion_match_func)
        self.user_entry.set_completion(self.entry_completion)
        self.populate_list_store()

        self.xml.connect_signals(self)

    def run(self):
        s = self.dialog.run()

        if not s:
            self.dialog.destroy()
            return

        data = {}
        data['user'] = self.xml.get_object('user_entry').get_text()
        data['value'] = self.xml.get_object('debt_value').get_value()

        bf = self.xml.get_object('notes').get_buffer()
        data['notes'] = bf.get_text(bf.get_start_iter(),
                                    bf.get_end_iter())

        self.dialog.destroy()
        return data

    def entry_completion_match_func(self, completion, key, iter):

        model = completion.get_model()
        full_name = model.get_value(iter, 0)
        nick = model.get_value(iter, 1)

        if nick.startswith(key) or full_name.lower().startswith(key):
            return True

        return False

    def populate_list_store(self):
        for user in self.users_manager.get_all():
            self.entry_list_store.append((user.nick, user.full_name))

    def on_user_entry_changed(self, obj):

        if self._user_entry_timeout_id > 0:
            gobject.source_remove(self._user_entry_timeout_id)

        timeout = 1000

        self._user_entry_timeout_id = gobject.timeout_add(timeout,
                                    self.on_user_entry_changed_done)

    def on_user_entry_changed_done(self):
        nick = self.user_entry.get_text()
        out = self.users_manager.get_credit_and_id(nick)

        if out:
            self.user_found = True
            self.xml.get_object('found_status').set_text("")

        elif nick == "":
            self.user_found = False
            self.xml.get_object('found_status').set_text("")

        else:
            self.user_found = False
            self.xml.get_object('found_status').set_text(_("User not found"))

        self.xml.get_object('ok_button').set_sensitive(self.user_found)

        if self.user_found:
            self.xml.get_object('user_status').set_from_stock('gtk-apply',
                                                              gtk.ICON_SIZE_MENU)
        else:
            self.xml.get_object('user_status').set_from_file(None)

